Some rough notes about the Oz threading model
=============================================

(almost verbatim from CTM)

Scheduling
----------

Fair scheduling through round-robin.

Needs not be deterministic (would be nice, especially when debugging,
but probably impossible to achieve).

With priority levels : three queues exist, which manage high, medium,
low priority threads. The time slice ratio for these is
100:10:1. Threads inherit the priority of their parent.

Mozart uses an external timer approach to implement thread preemption.

Thread ops
----------

All these ops are defined in a Thread namespace/module.

this()               -> current thread's name (*not* another thread's name)
state(t)             -> return state of t in {runnable, blocked, terminated}
suspend(t)            : suspend t
resume(t)             : resume execution of t
preempt(t)            : preempt t
terminate(t)          : terminate t immediately
injectException(t, e) : raise exception e in t
setPriority(t, p)     : set t's priority to p

Interestingly, coroutines can be build upon this thread
API. Coroutines have two ops : spawn and resume.

spawn(p)             -> creates a coroutine with procedure p, returns pid
resume(c)             : transfers control from current coroutine to c

The implementation of these ops in terms of the threads API is as
follows :

def spawn(p):
    in_thread:
        pid = Thread.this()
        Thread.suspend(pid)
        p()

def resume(cid):
    Thread.resume cid
    Thread.suspend(Thread.this())


Thread communication
--------------------

No shared state is allowed (in the model we are interested in
anyway). Threads communicate through dataflow variables, which
alleviates the need for explicit locking/monitoring.

While this restricts somewhat what can be done, it is the most
expressive way of using threads without shooting oneself in the
foot. Concurrent constraint programming uses and abuses of this kind
of concurrency.

Dataflow variable allow streams to be created. "A stream is a
potentially unbounded list of messages, i.e a list whose tail is an
unbound dataflow variable. Receiving a message is reading a stream
element. Each variable is bound by only one thread".

If you practice UNIX pipes, you have some basis to understand
this. Also see http://www.jpaulmorrison.com/fbp/.


Synchronization
---------------

The combination of threads and dataflow variables leads to implicit
synchronization : that means synchronization is not textually visible
in the source code but follow from the semantics of dataflow variables
; using such a variable implies synchronization on the variable being
bound to a value.

Eager execution (the mere fact of executing statements as they present
themselves to the interpreter, withou delay) plus dataflow vars also
implies "supply-driven synchronization" ; operations wait
(synchronize) on the availability of their arguments. 

One important benefit is that the dependencies between parts of a
program are implicitly and dynamically computed (it depends on the
availability of the data instead of decision of the programmer).

Doing computations with only partial information is possible ("partial
values can be seen as complete values that are only partially known").

Dataflow variables
------------------

(see http://www.sics.se/~frej/flow_java/ for an implementation of
dataflow variables in Java).

Dataflow variables were originally discovered by people working on
logic programming and were called logic variables. They have
well-defined logic semantics.

"A dataflow variable is stateful, because it can change state
(transition from unbound to bound to a value) -- but it can be bound
to only one value in its lifetime (single-assignement variable is a
term used sometimes to describe them).

A dataflow variable is stateless, because binding is monotonic. That
means we can only add information to the binding, but not remove or
alter information".

Difference with single-assignment variables
-------------------------------------------

A single-assignment variable is a mutable variable that can be
assigned only once. This differ form a dataflow variable in that the
latter can be assigned (perhaps multiple times) to many partial
values, provided the partial values are compatible (unifiable) with
each other.

