# This file describes the nodes of the AST in ast.py.  The module is
# generated by astgen.py.  
# The descriptions use the following special notation to describe
# properties of the children:
#    *   this child is not a node
#    !   this child is a sequence that contains nodes in it
#    &   this child may be set to None
#  = ... a default value for the node constructor (optional args)
Module: doc*, node
Stmt: nodes!
Decorators: nodes!
AbstractFunction:
Function(AbstractFunction): decorators&, name*, argnames*, defaults!, flags*, doc*, code
Lambda(AbstractFunction): argnames*, defaults!, flags*, code
Class: name*, bases!, doc*, code
Pass: 
Break: 
Continue: 
For: assign, list, body, else_&
While: test, body, else_&
If: tests!, else_&
Exec: expr, locals&, globals&
From: modname*, names*
Import: names*
Raise: expr1&, expr2&, expr3&
TryFinally: body, final
TryExcept: body, handlers!, else_&
Return: value&
Yield: value
Const: value*
NoneConst:
StringConst: string_value*
NumberConst: number_value*
Print: nodes!, dest&
Printnl: nodes!, dest&
Discard: expr
AugAssign: node, op*, expr
Assign: nodes!, expr
AssSeq:
AssTuple(AssSeq): nodes!
AssList(AssSeq): nodes!
AssName: name*, flags*
AssAttr: expr, attrname*, flags*
ListComp: expr, quals!
ListCompFor: assign, list, ifs!
ListCompIf: test
GenExpr(AbstractFunction): code 
GenExprInner: expr, quals!
GenExprFor: assign, iter, ifs!
GenExprIf: test
List: nodes!
Dict: items!
UnaryOp:
Not(UnaryOp): expr
Compare: expr, ops!
Name: varname*
Global: names*
Backquote(UnaryOp): expr
Getattr: expr, attrname*
CallFunc: node, args!, star_args& = None, dstar_args& = None
Keyword: name*, expr
Subscript: expr, flags*, subs!
Ellipsis: 
Sliceobj: nodes!
Slice: expr, flags*, lower&, upper&
Assert: test, fail&
Tuple: nodes!
AbstractTest:
Or(AbstractTest): nodes!
And(AbstractTest): nodes!
BitOp:
Bitor(BitOp): nodes!
Bitxor(BitOp): nodes!
Bitand(BitOp): nodes!
BinaryOp:
LeftShift(BinaryOp): (left, right)
RightShift(BinaryOp): (left, right)
Add(BinaryOp): (left, right)
Sub(BinaryOp): (left, right)
Mul(BinaryOp): (left, right)
Div(BinaryOp): (left, right)
Mod(BinaryOp): (left, right)
Power(BinaryOp): (left, right)
FloorDiv(BinaryOp): (left, right)
UnaryAdd(UnaryOp): expr
UnarySub(UnaryOp): expr
Invert(UnaryOp): expr

init(Function):
    self.varargs = self.kwargs = 0
    if flags & CO_VARARGS:
        self.varargs = 1
    if flags & CO_VARKEYWORDS:
        self.kwargs = 1

init(Lambda):
    self.varargs = self.kwargs = 0
    if flags & CO_VARARGS:
        self.varargs = 1
    if flags & CO_VARKEYWORDS:
        self.kwargs = 1

init(GenExpr):
    self.argnames = [AssName('[outmost-iterable]', OP_ASSIGN)]
    self.varargs = self.kwargs = 0

init(GenExprFor):
    self.is_outmost = False

flatten_nodes(Compare.ops):
    # ops is a list of couples (op_name, node)
    for op_name, node in self.ops:
        nodelist.append(node)

flatten_nodes(TryExcept.handlers):
    # handlers is a list of triplets (expr1, expr2, body)
    for expr1, expr2, body in self.handlers:
        if expr1 is not None:
            nodelist.append(expr1)
        if expr2 is not None:
            nodelist.append(expr2)
        if body is not None:
            nodelist.append(body)

flatten_nodes(Dict.items):
    # items is a list of couples (node (key), node (value))
    for key, value in self.items:
        nodelist.append(key)
        nodelist.append(value)

flatten_nodes(If.tests):
    # tests is a list of couples (node (test), node (suite))
    for test, suite in self.tests:
        nodelist.append(test)
        nodelist.append(suite)

AssTuple.getArgNames(self):
    argnames = []
    for node in self.nodes:
        if isinstance(node, AssTuple):
            argnames.extend(node.getArgNames())
        elif isinstance(node, AssName):
            name = node.name
            assert isinstance(name, str)
            argnames.append(name)
        else:
            assert False, "should only have AssName and AssTuple as children"
    return argnames
