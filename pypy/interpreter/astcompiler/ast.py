"""Python abstract syntax node definitions

This file is automatically generated by Tools/compiler/astgen.py
"""
from consts import CO_VARARGS, CO_VARKEYWORDS, OP_ASSIGN
from pypy.interpreter.baseobjspace import Wrappable

def flatten(list):
    l = []
    for elt in list:
        t = type(elt)
        if t is tuple or t is list:
            for elt2 in flatten(elt):
                l.append(elt2)
        else:
            l.append(elt)
    return l

def flatten_nodes(list):
    return [n for n in flatten(list) if isinstance(n, Node)]

nodes = {}

class Node(Wrappable):
    """Abstract base class for ast nodes."""
    def __init__(self, lineno=-1):
        self.lineno = lineno
        self.filename = ""
        
    def getChildren(self):
        pass # implemented by subclasses
    def __iter__(self):
        for n in self.getChildren():
            yield n
    def asList(self): # for backwards compatibility
        return self.getChildren()
    def getChildNodes(self):
        return [] # implemented by subclasses
    def accept(self, visitor):
        return visitor.visitNode(self)
    def flatten(self):
        res = []
        nodes = self.getChildNodes()
        if nodes:
            for n in nodes:
                res.extend( n.flatten() )
        else:
            res.append( self )
        return res

        
class EmptyNode(Node):
    def accept(self, visitor):
        return visitor.visitEmptyNode(self)

class Expression(Node):
    # Expression is an artificial node class to support "eval"
    nodes["expression"] = "Expression"
    def __init__(self, node):
        Node.__init__(self)
        self.node = node

    def getChildren(self):
        return [self.node,]

    def getChildNodes(self):
        return [self.node,]

    def __repr__(self):
        return "Expression(%s)" % (repr(self.node))

    def accept(self, visitor):
        return visitor.visitExpression(self)

class Add(Node):
    def __init__(self, (left, right), lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "Add((%s, %s))" % (repr(self.left), repr(self.right))

    def accept(self, visitor):
        return visitor.visitAdd(self)

class And(Node):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return nodelist

    def __repr__(self):
        return "And(%s)" % (repr(self.nodes),)

    def accept(self, visitor):
        return visitor.visitAnd(self)

class AssAttr(Node):
    def __init__(self, expr, attrname, flags, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        self.attrname = attrname
        self.flags = flags

    def getChildren(self):
        return self.expr, self.attrname, self.flags

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "AssAttr(%s, %s, %s)" % (repr(self.expr), repr(self.attrname), repr(self.flags))

    def accept(self, visitor):
        return visitor.visitAssAttr(self)

class AssList(Node):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return nodelist

    def __repr__(self):
        return "AssList(%s)" % (repr(self.nodes),)

    def accept(self, visitor):
        return visitor.visitAssList(self)

class AssName(Node):
    def __init__(self, name, flags, lineno=-1):
        Node.__init__(self, lineno)
        self.name = name
        self.flags = flags

    def getChildren(self):
        return self.name, self.flags

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "AssName(%s, %s)" % (repr(self.name), repr(self.flags))

    def accept(self, visitor):
        return visitor.visitAssName(self)

class AssTuple(Node):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return nodelist

    def __repr__(self):
        return "AssTuple(%s)" % (repr(self.nodes),)

    def accept(self, visitor):
        return visitor.visitAssTuple(self)

class Assert(Node):
    def __init__(self, test, fail, lineno=-1):
        Node.__init__(self, lineno)
        self.test = test
        self.fail = fail

    def getChildren(self):
        children = []
        children.append(self.test)
        children.append(self.fail)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.test)
        if self.fail is not None:
            nodelist.append(self.fail)
        return nodelist

    def __repr__(self):
        return "Assert(%s, %s)" % (repr(self.test), repr(self.fail))

    def accept(self, visitor):
        return visitor.visitAssert(self)

class Assign(Node):
    def __init__(self, nodes, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes
        self.expr = expr

    def getChildren(self):
        children = []
        children.extend(flatten(self.nodes))
        children.append(self.expr)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        nodelist.append(self.expr)
        return nodelist

    def __repr__(self):
        return "Assign(%s, %s)" % (repr(self.nodes), repr(self.expr))

    def accept(self, visitor):
        return visitor.visitAssign(self)

class AugAssign(Node):
    def __init__(self, node, op, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.node = node
        self.op = op
        self.expr = expr

    def getChildren(self):
        return self.node, self.op, self.expr

    def getChildNodes(self):
        return [self.node, self.expr]

    def __repr__(self):
        return "AugAssign(%s, %s, %s)" % (repr(self.node), repr(self.op), repr(self.expr))

    def accept(self, visitor):
        return visitor.visitAugAssign(self)

class Backquote(Node):
    def __init__(self, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr

    def getChildren(self):
        return self.expr,

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "Backquote(%s)" % (repr(self.expr),)

    def accept(self, visitor):
        return visitor.visitBackquote(self)

class Bitand(Node):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return nodelist

    def __repr__(self):
        return "Bitand(%s)" % (repr(self.nodes),)

    def accept(self, visitor):
        return visitor.visitBitand(self)

class Bitor(Node):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return nodelist

    def __repr__(self):
        return "Bitor(%s)" % (repr(self.nodes),)

    def accept(self, visitor):
        return visitor.visitBitor(self)

class Bitxor(Node):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return nodelist

    def __repr__(self):
        return "Bitxor(%s)" % (repr(self.nodes),)

    def accept(self, visitor):
        return visitor.visitBitxor(self)

class Break(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Break()"

    def accept(self, visitor):
        return visitor.visitBreak(self)

class CallFunc(Node):
    def __init__(self, node, args, star_args = None, dstar_args = None, lineno=-1):
        Node.__init__(self, lineno)
        self.node = node
        self.args = args
        self.star_args = star_args
        self.dstar_args = dstar_args

    def getChildren(self):
        children = []
        children.append(self.node)
        children.extend(flatten(self.args))
        children.append(self.star_args)
        children.append(self.dstar_args)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.node)
        nodelist.extend(flatten_nodes(self.args))
        if self.star_args is not None:
            nodelist.append(self.star_args)
        if self.dstar_args is not None:
            nodelist.append(self.dstar_args)
        return nodelist

    def __repr__(self):
        return "CallFunc(%s, %s, %s, %s)" % (repr(self.node), repr(self.args), repr(self.star_args), repr(self.dstar_args))

    def accept(self, visitor):
        return visitor.visitCallFunc(self)

class Class(Node):
    def __init__(self, name, bases, doc, code, lineno=-1):
        Node.__init__(self, lineno)
        self.name = name
        self.bases = bases
        self.doc = doc
        self.code = code

    def getChildren(self):
        children = []
        children.append(self.name)
        children.extend(flatten(self.bases))
        children.append(self.doc)
        children.append(self.code)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.bases))
        nodelist.append(self.code)
        return nodelist

    def __repr__(self):
        return "Class(%s, %s, %s, %s)" % (repr(self.name), repr(self.bases), repr(self.doc), repr(self.code))

    def accept(self, visitor):
        return visitor.visitClass(self)

class Compare(Node):
    def __init__(self, expr, ops, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        # ops is a list of couples (op_name, node)
        self.ops = ops

    def getChildren(self):
        children = []
        children.append(self.expr)
        children.extend(flatten(self.ops))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        # this is a replacement of flatten_nodes
        for op_name, node in self.ops:
            nodelist.append(node)
        # nodelist.extend(flatten_nodes(self.ops))
        return nodelist

    def __repr__(self):
        return "Compare(%s, %s)" % (repr(self.expr), repr(self.ops))

    def accept(self, visitor):
        return visitor.visitCompare(self)

class Const(Node):
    def __init__(self, value, lineno=-1):
        Node.__init__(self, lineno)
        self.value = value

    def getChildren(self):
        return self.value,

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Const(%s)" % (repr(self.value),)

    def accept(self, visitor):
        return visitor.visitConst(self)

class Continue(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Continue()"

    def accept(self, visitor):
        return visitor.visitContinue(self)

class Decorators(Node):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return nodelist

    def __repr__(self):
        return "Decorators(%s)" % (repr(self.nodes),)

    def accept(self, visitor):
        return visitor.visitDecorators(self)

class Dict(Node):
    def __init__(self, items, lineno=-1):
        Node.__init__(self, lineno)
        # items is a list of couples (node (key), node (value))
        self.items = items

    def getChildren(self):
        return tuple(flatten(self.items))

    def getChildNodes(self):
        nodelist = []
        # replacement for flatten_nodes()
        for key, value in self.items:
            nodelist.append(key)
            nodelist.append(value)
        # nodelist.extend(flatten_nodes(self.items))
        return nodelist

    def __repr__(self):
        return "Dict(%s)" % (repr(self.items),)

    def accept(self, visitor):
        return visitor.visitDict(self)

class Discard(Node):
    def __init__(self, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr

    def getChildren(self):
        return self.expr,

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "Discard(%s)" % (repr(self.expr),)

    def accept(self, visitor):
        return visitor.visitDiscard(self)

class Div(Node):
    def __init__(self, (left, right), lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "Div((%s, %s))" % (repr(self.left), repr(self.right))

    def accept(self, visitor):
        return visitor.visitDiv(self)

class Ellipsis(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Ellipsis()"

    def accept(self, visitor):
        return visitor.visitEllipsis(self)

class Exec(Node):
    def __init__(self, expr, locals, globals, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        self.locals = locals
        self.globals = globals

    def getChildren(self):
        children = []
        children.append(self.expr)
        children.append(self.locals)
        children.append(self.globals)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        if self.locals is not None:
            nodelist.append(self.locals)
        if self.globals is not None:
            nodelist.append(self.globals)
        return nodelist

    def __repr__(self):
        return "Exec(%s, %s, %s)" % (repr(self.expr), repr(self.locals), repr(self.globals))

    def accept(self, visitor):
        return visitor.visitExec(self)

class FloorDiv(Node):
    def __init__(self, (left, right), lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "FloorDiv((%s, %s))" % (repr(self.left), repr(self.right))

    def accept(self, visitor):
        return visitor.visitFloorDiv(self)

class For(Node):
    def __init__(self, assign, list, body, else_, lineno=-1):
        Node.__init__(self, lineno)
        self.assign = assign
        self.list = list
        self.body = body
        self.else_ = else_

    def getChildren(self):
        children = []
        children.append(self.assign)
        children.append(self.list)
        children.append(self.body)
        children.append(self.else_)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.assign)
        nodelist.append(self.list)
        nodelist.append(self.body)
        if self.else_ is not None:
            nodelist.append(self.else_)
        return nodelist

    def __repr__(self):
        return "For(%s, %s, %s, %s)" % (repr(self.assign), repr(self.list), repr(self.body), repr(self.else_))

    def accept(self, visitor):
        return visitor.visitFor(self)

class From(Node):
    def __init__(self, modname, names, lineno=-1):
        Node.__init__(self, lineno)
        self.modname = modname
        self.names = names

    def getChildren(self):
        return self.modname, self.names

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "From(%s, %s)" % (repr(self.modname), repr(self.names))

    def accept(self, visitor):
        return visitor.visitFrom(self)

class Function(Node):
    def __init__(self, decorators, name, argnames, defaults, flags, doc, code, lineno=-1):
        Node.__init__(self, lineno)
        self.decorators = decorators
        self.name = name
        self.argnames = argnames
        self.defaults = defaults
        self.flags = flags
        self.doc = doc
        self.code = code
        self.varargs = self.kwargs = 0
        if flags & CO_VARARGS:
            self.varargs = 1
        if flags & CO_VARKEYWORDS:
            self.kwargs = 1
    


    def getChildren(self):
        children = []
        children.append(self.decorators)
        children.append(self.name)
        children.append(self.argnames)
        children.extend(flatten(self.defaults))
        children.append(self.flags)
        children.append(self.doc)
        children.append(self.code)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        if self.decorators is not None:
            nodelist.append(self.decorators)
        nodelist.extend(flatten_nodes(self.defaults))
        nodelist.append(self.code)
        return nodelist

    def __repr__(self):
        return "Function(%s, %s, %s, %s, %s, %s, %s)" % (repr(self.decorators), repr(self.name), repr(self.argnames), repr(self.defaults), repr(self.flags), repr(self.doc), repr(self.code))

    def accept(self, visitor):
        return visitor.visitFunction(self)

class GenExpr(Node):
    def __init__(self, code, lineno=-1):
        Node.__init__(self, lineno)
        self.code = code
        self.argnames = [AssName('[outmost-iterable]', OP_ASSIGN)]
        self.varargs = self.kwargs = 0
    


    def getChildren(self):
        return self.code,

    def getChildNodes(self):
        return [self.code,]

    def __repr__(self):
        return "GenExpr(%s)" % (repr(self.code),)

    def accept(self, visitor):
        return visitor.visitGenExpr(self)

class GenExprFor(Node):
    def __init__(self, assign, iter, ifs, lineno=-1):
        Node.__init__(self, lineno)
        self.assign = assign
        self.iter = iter
        self.ifs = ifs
        self.is_outmost = False


    def getChildren(self):
        children = []
        children.append(self.assign)
        children.append(self.iter)
        children.extend(flatten(self.ifs))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.assign)
        nodelist.append(self.iter)
        nodelist.extend(flatten_nodes(self.ifs))
        return nodelist

    def __repr__(self):
        return "GenExprFor(%s, %s, %s)" % (repr(self.assign), repr(self.iter), repr(self.ifs))

    def accept(self, visitor):
        return visitor.visitGenExprFor(self)

class GenExprIf(Node):
    def __init__(self, test, lineno=-1):
        Node.__init__(self, lineno)
        self.test = test

    def getChildren(self):
        return self.test,

    def getChildNodes(self):
        return [self.test,]

    def __repr__(self):
        return "GenExprIf(%s)" % (repr(self.test),)

    def accept(self, visitor):
        return visitor.visitGenExprIf(self)

class GenExprInner(Node):
    def __init__(self, expr, quals, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        self.quals = quals

    def getChildren(self):
        children = []
        children.append(self.expr)
        children.extend(flatten(self.quals))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        nodelist.extend(flatten_nodes(self.quals))
        return nodelist

    def __repr__(self):
        return "GenExprInner(%s, %s)" % (repr(self.expr), repr(self.quals))

    def accept(self, visitor):
        return visitor.visitGenExprInner(self)

class Getattr(Node):
    def __init__(self, expr, attrname, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        self.attrname = attrname

    def getChildren(self):
        return self.expr, self.attrname

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "Getattr(%s, %s)" % (repr(self.expr), repr(self.attrname))

    def accept(self, visitor):
        return visitor.visitGetattr(self)

class Global(Node):
    def __init__(self, names, lineno=-1):
        Node.__init__(self, lineno)
        self.names = names

    def getChildren(self):
        return self.names,

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Global(%s)" % (repr(self.names),)

    def accept(self, visitor):
        return visitor.visitGlobal(self)

class If(Node):
    def __init__(self, tests, else_, lineno=-1):
        Node.__init__(self, lineno)
        self.tests = tests
        self.else_ = else_

    def getChildren(self):
        children = []
        children.extend(flatten(self.tests))
        children.append(self.else_)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.tests))
        if self.else_ is not None:
            nodelist.append(self.else_)
        return nodelist

    def __repr__(self):
        return "If(%s, %s)" % (repr(self.tests), repr(self.else_))

    def accept(self, visitor):
        return visitor.visitIf(self)

class Import(Node):
    def __init__(self, names, lineno=-1):
        Node.__init__(self, lineno)
        self.names = names

    def getChildren(self):
        return self.names,

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Import(%s)" % (repr(self.names),)

    def accept(self, visitor):
        return visitor.visitImport(self)

class Invert(Node):
    def __init__(self, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr

    def getChildren(self):
        return self.expr,

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "Invert(%s)" % (repr(self.expr),)

    def accept(self, visitor):
        return visitor.visitInvert(self)

class Keyword(Node):
    def __init__(self, name, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.name = name
        self.expr = expr

    def getChildren(self):
        return self.name, self.expr

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "Keyword(%s, %s)" % (repr(self.name), repr(self.expr))

    def accept(self, visitor):
        return visitor.visitKeyword(self)

class Lambda(Node):
    def __init__(self, argnames, defaults, flags, code, lineno=-1):
        Node.__init__(self, lineno)
        self.argnames = argnames
        self.defaults = defaults
        self.flags = flags
        self.code = code
        self.varargs = self.kwargs = 0
        if flags & CO_VARARGS:
            self.varargs = 1
        if flags & CO_VARKEYWORDS:
            self.kwargs = 1
    


    def getChildren(self):
        children = []
        children.append(self.argnames)
        children.extend(flatten(self.defaults))
        children.append(self.flags)
        children.append(self.code)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.defaults))
        nodelist.append(self.code)
        return nodelist

    def __repr__(self):
        return "Lambda(%s, %s, %s, %s)" % (repr(self.argnames), repr(self.defaults), repr(self.flags), repr(self.code))

    def accept(self, visitor):
        return visitor.visitLambda(self)

class LeftShift(Node):
    def __init__(self, (left, right), lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "LeftShift((%s, %s))" % (repr(self.left), repr(self.right))

    def accept(self, visitor):
        return visitor.visitLeftShift(self)

class List(Node):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return nodelist

    def __repr__(self):
        return "List(%s)" % (repr(self.nodes),)

    def accept(self, visitor):
        return visitor.visitList(self)

class ListComp(Node):
    def __init__(self, expr, quals, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        self.quals = quals

    def getChildren(self):
        children = []
        children.append(self.expr)
        children.extend(flatten(self.quals))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        nodelist.extend(flatten_nodes(self.quals))
        return nodelist

    def __repr__(self):
        return "ListComp(%s, %s)" % (repr(self.expr), repr(self.quals))

    def accept(self, visitor):
        return visitor.visitListComp(self)

class ListCompFor(Node):
    def __init__(self, assign, list, ifs, lineno=-1):
        Node.__init__(self, lineno)
        self.assign = assign
        self.list = list
        self.ifs = ifs

    def getChildren(self):
        children = []
        children.append(self.assign)
        children.append(self.list)
        children.extend(flatten(self.ifs))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.assign)
        nodelist.append(self.list)
        nodelist.extend(flatten_nodes(self.ifs))
        return nodelist

    def __repr__(self):
        return "ListCompFor(%s, %s, %s)" % (repr(self.assign), repr(self.list), repr(self.ifs))

    def accept(self, visitor):
        return visitor.visitListCompFor(self)

class ListCompIf(Node):
    def __init__(self, test, lineno=-1):
        Node.__init__(self, lineno)
        self.test = test

    def getChildren(self):
        return self.test,

    def getChildNodes(self):
        return [self.test,]

    def __repr__(self):
        return "ListCompIf(%s)" % (repr(self.test),)

    def accept(self, visitor):
        return visitor.visitListCompIf(self)

class Mod(Node):
    def __init__(self, (left, right), lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "Mod((%s, %s))" % (repr(self.left), repr(self.right))

    def accept(self, visitor):
        return visitor.visitMod(self)

class Module(Node):
    def __init__(self, doc, node, lineno=-1):
        Node.__init__(self, lineno)
        self.doc = doc
        self.node = node

    def getChildren(self):
        return self.doc, self.node

    def getChildNodes(self):
        return [self.node,]

    def __repr__(self):
        return "Module(%s, %s)" % (repr(self.doc), repr(self.node))

    def accept(self, visitor):
        return visitor.visitModule(self)

class Mul(Node):
    def __init__(self, (left, right), lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "Mul((%s, %s))" % (repr(self.left), repr(self.right))

    def accept(self, visitor):
        return visitor.visitMul(self)

class Name(Node):
    def __init__(self, varname, lineno=-1):
        Node.__init__(self, lineno)
        self.varname = varname

    def getChildren(self):
        return self.varname,

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Name(%s)" % (repr(self.varname),)

    def accept(self, visitor):
        return visitor.visitName(self)

class NoneConst(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "NoneConst()"

    def accept(self, visitor):
        return visitor.visitNoneConst(self)

class Not(Node):
    def __init__(self, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr

    def getChildren(self):
        return self.expr,

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "Not(%s)" % (repr(self.expr),)

    def accept(self, visitor):
        return visitor.visitNot(self)

class NumberConst(Node):
    def __init__(self, number_value, lineno=-1):
        Node.__init__(self, lineno)
        self.number_value = number_value

    def getChildren(self):
        return self.number_value,

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "NumberConst(%s)" % (repr(self.number_value),)

    def accept(self, visitor):
        return visitor.visitNumberConst(self)

class Or(Node):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return nodelist

    def __repr__(self):
        return "Or(%s)" % (repr(self.nodes),)

    def accept(self, visitor):
        return visitor.visitOr(self)

class Pass(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Pass()"

    def accept(self, visitor):
        return visitor.visitPass(self)

class Power(Node):
    def __init__(self, (left, right), lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "Power((%s, %s))" % (repr(self.left), repr(self.right))

    def accept(self, visitor):
        return visitor.visitPower(self)

class Print(Node):
    def __init__(self, nodes, dest, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes
        self.dest = dest

    def getChildren(self):
        children = []
        children.extend(flatten(self.nodes))
        children.append(self.dest)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        if self.dest is not None:
            nodelist.append(self.dest)
        return nodelist

    def __repr__(self):
        return "Print(%s, %s)" % (repr(self.nodes), repr(self.dest))

    def accept(self, visitor):
        return visitor.visitPrint(self)

class Printnl(Node):
    def __init__(self, nodes, dest, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes
        self.dest = dest

    def getChildren(self):
        children = []
        children.extend(flatten(self.nodes))
        children.append(self.dest)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        if self.dest is not None:
            nodelist.append(self.dest)
        return nodelist

    def __repr__(self):
        return "Printnl(%s, %s)" % (repr(self.nodes), repr(self.dest))

    def accept(self, visitor):
        return visitor.visitPrintnl(self)

class Raise(Node):
    def __init__(self, expr1, expr2, expr3, lineno=-1):
        Node.__init__(self, lineno)
        self.expr1 = expr1
        self.expr2 = expr2
        self.expr3 = expr3

    def getChildren(self):
        children = []
        children.append(self.expr1)
        children.append(self.expr2)
        children.append(self.expr3)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        if self.expr1 is not None:
            nodelist.append(self.expr1)
        if self.expr2 is not None:
            nodelist.append(self.expr2)
        if self.expr3 is not None:
            nodelist.append(self.expr3)
        return nodelist

    def __repr__(self):
        return "Raise(%s, %s, %s)" % (repr(self.expr1), repr(self.expr2), repr(self.expr3))

    def accept(self, visitor):
        return visitor.visitRaise(self)

class Return(Node):
    def __init__(self, value, lineno=-1):
        Node.__init__(self, lineno)
        self.value = value

    def getChildren(self):
        return self.value,

    def getChildNodes(self):
        return [self.value,]

    def __repr__(self):
        return "Return(%s)" % (repr(self.value),)

    def accept(self, visitor):
        return visitor.visitReturn(self)

class RightShift(Node):
    def __init__(self, (left, right), lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "RightShift((%s, %s))" % (repr(self.left), repr(self.right))

    def accept(self, visitor):
        return visitor.visitRightShift(self)

class Slice(Node):
    def __init__(self, expr, flags, lower, upper, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        self.flags = flags
        self.lower = lower
        self.upper = upper

    def getChildren(self):
        children = []
        children.append(self.expr)
        children.append(self.flags)
        children.append(self.lower)
        children.append(self.upper)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        if self.lower is not None:
            nodelist.append(self.lower)
        if self.upper is not None:
            nodelist.append(self.upper)
        return nodelist

    def __repr__(self):
        return "Slice(%s, %s, %s, %s)" % (repr(self.expr), repr(self.flags), repr(self.lower), repr(self.upper))

    def accept(self, visitor):
        return visitor.visitSlice(self)

class Sliceobj(Node):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return nodelist

    def __repr__(self):
        return "Sliceobj(%s)" % (repr(self.nodes),)

    def accept(self, visitor):
        return visitor.visitSliceobj(self)

class Stmt(Node):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return nodelist

    def __repr__(self):
        return "Stmt(%s)" % (repr(self.nodes),)

    def accept(self, visitor):
        return visitor.visitStmt(self)

class StringConst(Node):
    def __init__(self, string_value, lineno=-1):
        Node.__init__(self, lineno)
        self.string_value = string_value

    def getChildren(self):
        return self.string_value,

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "StringConst(%s)" % (repr(self.string_value),)

    def accept(self, visitor):
        return visitor.visitStringConst(self)

class Sub(Node):
    def __init__(self, (left, right), lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "Sub((%s, %s))" % (repr(self.left), repr(self.right))

    def accept(self, visitor):
        return visitor.visitSub(self)

class Subscript(Node):
    def __init__(self, expr, flags, subs, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        self.flags = flags
        self.subs = subs

    def getChildren(self):
        children = []
        children.append(self.expr)
        children.append(self.flags)
        children.extend(flatten(self.subs))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        nodelist.extend(flatten_nodes(self.subs))
        return nodelist

    def __repr__(self):
        return "Subscript(%s, %s, %s)" % (repr(self.expr), repr(self.flags), repr(self.subs))

    def accept(self, visitor):
        return visitor.visitSubscript(self)

class TryExcept(Node):
    def __init__(self, body, handlers, else_, lineno=-1):
        Node.__init__(self, lineno)
        self.body = body
        # handlers is a list of triplets (expr1, expr2, body)
        self.handlers = handlers
        self.else_ = else_

    def getChildren(self):
        children = []
        children.append(self.body)
        children.extend(flatten(self.handlers))
        children.append(self.else_)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.body)
        # replacement for flatten_nodes(self.handlers)
        for expr1, expr2, body in self.handlers:
            if expr1 is not None:
                nodelist.append(expr1)
            if expr2 is not None:
                nodelist.append(expr2)
            if body is not None:
                nodelist.append(body)
        if self.else_ is not None:
            nodelist.append(self.else_)
        return nodelist

    def __repr__(self):
        return "TryExcept(%s, %s, %s)" % (repr(self.body), repr(self.handlers), repr(self.else_))

    def accept(self, visitor):
        return visitor.visitTryExcept(self)

class TryFinally(Node):
    def __init__(self, body, final, lineno=-1):
        Node.__init__(self, lineno)
        self.body = body
        self.final = final

    def getChildren(self):
        return self.body, self.final

    def getChildNodes(self):
        return [self.body, self.final]

    def __repr__(self):
        return "TryFinally(%s, %s)" % (repr(self.body), repr(self.final))

    def accept(self, visitor):
        return visitor.visitTryFinally(self)

class Tuple(Node):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(flatten_nodes(self.nodes))
        return nodelist

    def __repr__(self):
        return "Tuple(%s)" % (repr(self.nodes),)

    def accept(self, visitor):
        return visitor.visitTuple(self)

class UnaryAdd(Node):
    def __init__(self, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr

    def getChildren(self):
        return self.expr,

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "UnaryAdd(%s)" % (repr(self.expr),)

    def accept(self, visitor):
        return visitor.visitUnaryAdd(self)

class UnarySub(Node):
    def __init__(self, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr

    def getChildren(self):
        return self.expr,

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "UnarySub(%s)" % (repr(self.expr),)

    def accept(self, visitor):
        return visitor.visitUnarySub(self)

class While(Node):
    def __init__(self, test, body, else_, lineno=-1):
        Node.__init__(self, lineno)
        self.test = test
        self.body = body
        self.else_ = else_

    def getChildren(self):
        children = []
        children.append(self.test)
        children.append(self.body)
        children.append(self.else_)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.test)
        nodelist.append(self.body)
        if self.else_ is not None:
            nodelist.append(self.else_)
        return nodelist

    def __repr__(self):
        return "While(%s, %s, %s)" % (repr(self.test), repr(self.body), repr(self.else_))

    def accept(self, visitor):
        return visitor.visitWhile(self)

class Yield(Node):
    def __init__(self, value, lineno=-1):
        Node.__init__(self, lineno)
        self.value = value

    def getChildren(self):
        return self.value,

    def getChildNodes(self):
        return [self.value,]

    def __repr__(self):
        return "Yield(%s)" % (repr(self.value),)

    def accept(self, visitor):
        return visitor.visitYield(self)


class ASTVisitor(object):
    """This is a visitor base class used to provide the visit
    method in replacement of the former visitor.visit = walker.dispatch
    It could also use to identify base type for visit arguments of AST nodes
    """
    
    def default(self, node):
        for child in node.getChildNodes():
            child.accept(self)


    def visitAdd(self, node):
        return self.default( node )
    def visitAnd(self, node):
        return self.default( node )
    def visitAssAttr(self, node):
        return self.default( node )
    def visitAssList(self, node):
        return self.default( node )
    def visitAssName(self, node):
        return self.default( node )
    def visitAssTuple(self, node):
        return self.default( node )
    def visitAssert(self, node):
        return self.default( node )
    def visitAssign(self, node):
        return self.default( node )
    def visitAugAssign(self, node):
        return self.default( node )
    def visitBackquote(self, node):
        return self.default( node )
    def visitBitand(self, node):
        return self.default( node )
    def visitBitor(self, node):
        return self.default( node )
    def visitBitxor(self, node):
        return self.default( node )
    def visitBreak(self, node):
        return self.default( node )
    def visitCallFunc(self, node):
        return self.default( node )
    def visitClass(self, node):
        return self.default( node )
    def visitCompare(self, node):
        return self.default( node )
    def visitConst(self, node):
        return self.default( node )
    def visitContinue(self, node):
        return self.default( node )
    def visitDecorators(self, node):
        return self.default( node )
    def visitDict(self, node):
        return self.default( node )
    def visitDiscard(self, node):
        return self.default( node )
    def visitDiv(self, node):
        return self.default( node )
    def visitEllipsis(self, node):
        return self.default( node )
    def visitExec(self, node):
        return self.default( node )
    def visitFloorDiv(self, node):
        return self.default( node )
    def visitFor(self, node):
        return self.default( node )
    def visitFrom(self, node):
        return self.default( node )
    def visitFunction(self, node):
        return self.default( node )
    def visitGenExpr(self, node):
        return self.default( node )
    def visitGenExprFor(self, node):
        return self.default( node )
    def visitGenExprIf(self, node):
        return self.default( node )
    def visitGenExprInner(self, node):
        return self.default( node )
    def visitGetattr(self, node):
        return self.default( node )
    def visitGlobal(self, node):
        return self.default( node )
    def visitIf(self, node):
        return self.default( node )
    def visitImport(self, node):
        return self.default( node )
    def visitInvert(self, node):
        return self.default( node )
    def visitKeyword(self, node):
        return self.default( node )
    def visitLambda(self, node):
        return self.default( node )
    def visitLeftShift(self, node):
        return self.default( node )
    def visitList(self, node):
        return self.default( node )
    def visitListComp(self, node):
        return self.default( node )
    def visitListCompFor(self, node):
        return self.default( node )
    def visitListCompIf(self, node):
        return self.default( node )
    def visitMod(self, node):
        return self.default( node )
    def visitModule(self, node):
        return self.default( node )
    def visitMul(self, node):
        return self.default( node )
    def visitName(self, node):
        return self.default( node )
    def visitNoneConst(self, node):
        return self.default( node )
    def visitNot(self, node):
        return self.default( node )
    def visitNumberConst(self, node):
        return self.default( node )
    def visitOr(self, node):
        return self.default( node )
    def visitPass(self, node):
        return self.default( node )
    def visitPower(self, node):
        return self.default( node )
    def visitPrint(self, node):
        return self.default( node )
    def visitPrintnl(self, node):
        return self.default( node )
    def visitRaise(self, node):
        return self.default( node )
    def visitReturn(self, node):
        return self.default( node )
    def visitRightShift(self, node):
        return self.default( node )
    def visitSlice(self, node):
        return self.default( node )
    def visitSliceobj(self, node):
        return self.default( node )
    def visitStmt(self, node):
        return self.default( node )
    def visitStringConst(self, node):
        return self.default( node )
    def visitSub(self, node):
        return self.default( node )
    def visitSubscript(self, node):
        return self.default( node )
    def visitTryExcept(self, node):
        return self.default( node )
    def visitTryFinally(self, node):
        return self.default( node )
    def visitTuple(self, node):
        return self.default( node )
    def visitUnaryAdd(self, node):
        return self.default( node )
    def visitUnarySub(self, node):
        return self.default( node )
    def visitWhile(self, node):
        return self.default( node )
    def visitYield(self, node):
        return self.default( node )

for name, obj in globals().items():
    if isinstance(obj, type) and issubclass(obj, Node):
        nodes[name.lower()] = obj
