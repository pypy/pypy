Independent project ideas in PyPy
=================================

PyPy allows experimentation in many directions -- indeed facilitating
experimentation in language implementation was one of the main motivations for
the project.  This page is meant to collect some ideas of things to try.

If you are a student, maybe you will be inspired to make a proposal for our
`Summer of PyPy`_ campaign: you will have an experienced PyPy developer as a
mentor and be invited to attend one or two of our sprints, with travel and
accomodation costs refunded.

Feel free to suggest new ideas and discuss them in #pypy on the freenode IRC
network or the pypy-dev mailing list (see the contact_ page).

-----------

.. contents::

Experiment with optimizations
-----------------------------

A research project: experiment with optimizations in PyPy, e.g. by trying
various **data structures** for dicts or other built-in objects, by switching
between data structures at run-time, comparing results for different
applications, etc.  This should produce experimental results (mostly timings,
memory usage trade-offs) as much as code.  (The point of PyPy is that we can
do this without making the interpreted applications aware of the optimization
at all.)

For example, we have started some work on:

* lazy string slices (slicing a string gives an object that references a part
  of the original string).

* lazily concatenated strings (repeated additions and joins are done
  incrementally).

* dictionaries specialized for string-only keys.




Start or improve a back-end
---------------------------

PyPy has complete, or nearly so, back-ends for C, LLVM and CLI/.NET and
partial backends for Common Lisp, Squeak and the JVM.  It would be an
interesting project to improve either of these partial backends, or start one
for another platform (objective C comes to mind).

Improve one of the JIT back-ends
--------------------------------

PyPy's Just-In-Time compiler relies on two assembler backends for actual code
generation: One for PowerPC and one for i386. Those two backends so far are
mostly working, but nearly no effort was made to make them produce good
assembler. This is an area where quite some improvements could be made.
Another idea in a similar vein would be to use LLVM to re-compile functions
that are particularly often used (LLVM cannot be used for *all* code
generation, since it can only work on function at a time).

Write a new front end
---------------------

Write an interpreter for **another dynamic language** in the PyPy framework.
For example, a Scheme interpreter would be suitable.  Ruby too (though
the latter is probably more than two months of work), or Lua, or ...

We have a somewhat useable `Prolog interpreter`_ and the beginnings of a
`JavaScript interpreter`_

Investigate restricted execution models
---------------------------------------

Revive **rexec**\ : implement security checks, sandboxing, or some similar
model within PyPy (which, if I may venture an opinion, makes more sense and is
more robust than trying to do it in CPython).

There are multiple approaches that can be discussed and tried.  One of them is
about safely executing limited snippets of untrusted RPython code (see
http://codespeak.net/pipermail/pypy-dev/2006q2/003131.html).  More general
approaches, to execute general but untrusted Python code on top of PyPy,
require more design.  The object space model of PyPy would easily allow
objects to be tagged and tracked.  The translation of PyPy would also be a
good place to insert e.g. systematic checks around all system calls.


Experiment with distribution and persistence
--------------------------------------------

One of the advantages of PyPy's implementation is that the Python-level type
of an object and its implementation are completely independent.  This should
allow a much more intuitive interface to, for example, objects that are backed
by a persistent store, or whose implementation lives on a remote server.

The recently added "transparent proxy" objects are a key step in this
direction; now all that remains is to implement the interesting bits :-)

An example project might be to implement functionality akin to the `ZODB's
Persistent class`_, without the need for the _p_changed hacks, and in pure
Python code.

Numeric/NumPy/numarray support
------------------------------

At the EuroPython sprint, some work was done on making RPython's annotator
recognise Numeric arrays, with the goal of allowing programs using them to be
efficiently translated.  It would be a reasonably sized project to finish this
work, i.e. allow RPython programs to use some Numeric facilities.
Additionally, these facilities could be exposed to applications interpreted by
the translated PyPy interpreter.



Extension modules
-----------------

Rewrite one or several CPython extension modules to be based on **ctypes**
(newly integrated in Python 2.5): this is generally useful for Python
developers, and it is now the best path to write extension modules that are
compatible with both CPython and PyPy.  This is done with the `extension
compiler`_ component of PyPy, which will likely require some attention as
well.

Modules where some work is already done:

* ``_socket``, ``os``, ``select`` (unfinished yet, feel free to help;
  see e.g. http://codespeak.net/svn/pypy/dist/pypy/module/_socket/).

* SSL for socket, ``bz2``, ``fcntl``, ``mmap`` and ``time``: part of the
  Summer of Code project of Lawrence Oluyede
  (http://codespeak.net/svn/user/rhymes/).

You are free to pick any other CPython module, either standard or third-party
(if relatively well-known).  Note that some modules exist in a ctypes version
already, which would be a good start for porting them to PyPy's extension
compiler.  We'd particularly appreciate ``readline`` :-)



Extend py.execnet to a peer-to-peer model
-----------------------------------------

* Work on a P2P model of distributed execution (extending `py.execnet`_) 
  that allows `py.test`_ and other upcoming utilities to make use of a 
  network of computers executing python tasks (e.g. tests or PyPy build tasks). 

* Make a client tool and according libraries to instantiate a (dynamic) network
  of computers executing centrally managed tasks (e.g. build or test ones). 
  (This may make use of a P2P model or not, both is likely feasible). 

Or else...
----------

* Improve `py.test`_ to contain benchmarking and/or better reporting
  (e.g. cool html or PDF reports).

* Constraint programming: `efficient propagators for specialized
  finite domains`_ (like numbers, sets, intervals).

* A `code templating solution`_ for Python code, allowing to extend
  the language syntax, control flow operators, etc.

...or whatever else interests you!

Note: currently it is a bit difficult for us to identify nice independent
sub-tasks in the context of the JIT compiler of PyPy...

Feel free to mention your interest and discuss these ideas on the `pypy-dev
mailing list`_.  You can also have a look around our documentation_.


.. _`efficient propagators for specialized finite domains`: http://codespeak.net/svn/pypy/extradoc/soc-2006/constraints.txt
.. _`py.test`: http://codespeak.net/py/current/doc/test.html
.. _`py.execnet`: http://codespeak.net/py/current/doc/execnet.html
.. _`Prolog interpreter`: http://codespeak.net/svn/user/cfbolz/hack/prolog/interpreter
.. _`JavaScript interpreter`: ../../../pypy/lang/js
.. _`extension compiler`: extcompiler.html
.. _`object spaces`: objspace.html
.. _`code templating solution`: http://codespeak.net/svn/pypy/extradoc/soc-2006/code-templating.txt

.. _documentation: index.html
.. _contact: contact.html
.. _`pypy-dev mailing list`: http://codespeak.net/mailman/listinfo/pypy-dev
.. _`Summer of PyPy`: summer-of-pypy.html
.. _`ZODB's Persistent class`: http://www.zope.org/Documentation/Books/ZDG/current/Persistence.stx
