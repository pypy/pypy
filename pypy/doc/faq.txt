==========================
Frequently Asked Questions
==========================

.. contents::


General
========================================================================

-------------
What is PyPy?
-------------

XXX

------------------------------------------------------
Why a new implementation of Python?  What does it add?
------------------------------------------------------

XXX

-----------------------------------
What is the status of the project? 
-----------------------------------

XXX status


--------------------------------
 Can it be used in practice yet?
--------------------------------

PyPy is a very broad project and its various parts have different levels of
maturity and of general applicability. For example our compiler toolchain is a
relatively mature part and can be used in practice already (see the faq about
`prolog and javascript`_). The Python interpreter that we have written is still
slightly `slower than CPython`_ and not yet a `drop in replacement`_.
In any case, our pygame graph viewer is *extremely* useful already!


.. _`drop in replacement`:

-----------------------------------------
Is PyPy a drop in replacement of CPython?
-----------------------------------------

Not completely yet. There are various areas where PyPy is lacking, such as
threading_ and `extension modules`_. The language features (including built in
types and functions) are very complete and well tested, though. That means that
projects not using many extension modules can probably directly use PyPy. A
project using extension modules might get some problems, though.

------------------------------
On what platforms does it run?
------------------------------

PyPy is regularly and extensively tested on Linux machines and on Mac OS X and
mostly works under Windows too (but is tested there less extensively). PyPy
needs a CPython running on the target platform to bootstrap, cross compilation
is not really meant to work, currently. Apart from that restriction, translating
PyPy is supposed to produce nice platform-independent code, so the chances are
not too bad that it works.

Currently (due to time restrictions) we are not trying hard to make PyPy support
64 bit platforms. While this seems to still mostly work out, a few modules won't
work on 64 bit machines, such as ``bz2``.

----------------------------------------------
Which Python version (2.x?) does PyPy support?
----------------------------------------------

PyPy currently targets to be fully compatible with Python 2.4. That means that
it contains the stdandard library of Python 2.4 and that it supports 2.4
features (such as decorators) but not the 2.5 features (with statement, ternary
operators).  The 2.5 features will probably be eventually suported, the most
important reasons why nobody is working on them is that we did not promise this
to the EU and have currently enough other tasks.

.. _threading:

-------------------------------------------------
Do threads work?  What are the modules that work?
-------------------------------------------------

Operating-System threads work in a limited way. If you enable the ``thread``
module then PyPy will get support for GIL based threading. One limitation is
that not that many IO operations actually release the GIL, which reduces the
usefulness of threads. On the other hand, PyPy fully supports `stackless-like
microthreads`_ (although both cannot be mixed yet).

As for other modules: The general rule of thumb is that pure-Python modules
work, C extension modules don't. Some of the C extension modules of the standard
library have been re-implemented in pure Python or as a mixed module (for some
there were also older pure-Python versions available). A (probably incomplete)
list:

 * pure Python implementations: binascii, cmath, collections, cPickle,
   cStringIO, datetime, functional, imp, itertools, md5, operator,
   sha, struct

 * mixed module implementations: exceptions, sys, __builtin__, posix
   _codecs, gc, _weakref, array, marshal, errno, math, _sre,  parser, symbol,
   _random, socket, unicodedata, mmap, fcntl, time, select, bz2, crypt, 
   signal


.. _`stackless-like microthreads`: stackless.html


.. _`extension modules`:

------------------------------------
Can I use CPython extension modules?
------------------------------------

No and there are no current plans to support this. CPython extension modules
rely heavily on CPython's C API which contains a lot of implementation details
like reference counting, exact C-level objects implementations etc.

Although if your module uses ctypes rather than C-level code, there is a hope.
You can try to write a mixed module (see next question).

------------------------------------------
How do I write extension modules for PyPy?
------------------------------------------

XXX


.. _`slower than CPython`:

-----------------
How fast is PyPy?
-----------------

.. _whysoslow:

As of August 2005, PyPy was successfully translated to C.  Compared to
CPython, the version of PyPy that still runs on top of CPython is slower by
a factor of 2000. The first translated version was roughly 300 times slower
than CPython. In later versions, we increased the speed. CPython was about
10-20 times as fast as version 0.8.0, 4-7 times as fast as version 0.9 and
2.4 - 5 times as fast as the current version (0.99).
Note that the speed heavily depends on the enabled options at compile time.


.. _`prolog and javascript`:

-----------------------------------------------------------------------
What is this talk about a JavaScript and a Prolog interpreter in PyPy?
-----------------------------------------------------------------------

Since a Python interpreter is a rather large and intricate thing, our toolsuite
became quite advanced to support it. Therefore people had the idea of using it
to implement interpreters for other dynamic languages than Python and get a lot
of things for free (translation to various languages, stackless features,
garbage collection, implementation of various things like arbitraryly long
integers). Therefore people started to implement a `JavaScript interpreter`_
(Leonardo Santagada as his Summer of PyPy project) and a `Prolog interpreter`_
(Carl Friedrich Bolz as his Masters thesis). Both projects are undocumented and
unfinished, at the moment (the Prolog interpreter being less unfinished).

.. _`JavaScript interpreter`: ../../pypy/lang/js
.. _`Prolog interpreter`: ../../pypy/lang/prolog


Development
========================================================================

-----------------------------------------------------------
How do I get into PyPy development?  Can I come to sprints?
-----------------------------------------------------------

Sure you can come to sprints! We always welcome newcomers and try to help them
get started in the project as much as possible (e.g. by providing tutorials and
pairing them with experienced PyPy developers). Newcomers should have some
Python experience and read some of the PyPy documentation before coming to a
sprint.

Coming to a sprint is usually also the best way to get into PyPy development.
If you want to start on your own, take a look at the list of `project
suggestions`_. If you get stuck or need advice, `contact us`_. Usually IRC is
the most immediate mean to get feedback (at least during some parts of the day,
many PyPy developers are in Europe) and the mailing list is better for long
discussions.

.. _`project suggestions`: project-ideas.html
.. _`contact us`: contact.html

----------------------------------
Why so many levels of abstraction?
----------------------------------

XXX see pypy-vm-construction

----------------------------------------------------------------------
I am getting strange errors while playing with PyPy, what should I do?
----------------------------------------------------------------------

It seems that a lot of strange, unexplainable problems can be magically
solved by removing all the \*.pyc files from the PyPy source tree
(the script `py.cleanup`_ from py/bin will do that for you).
Another thing you can do is removing the directory pypy/_cache
completely. If the error is persistent and still annoys you after this
treatment please send us a bug report (or even better, a fix :-)

.. _`py.cleanup`: http://codespeak.net/py/current/doc/bin.html


PyPy translation tool chain
========================================================================

------------------------------
What is this RPython language?
------------------------------

RPython is a restricted subset of the Python language. The restrictions are to
ensure that type inference (and eventually translation to other languages) of
the program is possible. These restrictions only apply after the full import
happened, so at import time arbitrary Python code can be executed. Another
important point is that the property of "being RPython" always applies to a full
program, not to single functions or modules (the translation tool chain does a
full program analysis).

The restrictions that apply to programs to be RPython mostly limit the ability
of mixing types in arbitrary ways. RPython does not allow the usage of two
different types in the same variable. In this respect (and in some others) it
feels a bit like Java. Other features not allowed in RPython are the usage of
special methods (``__XXX__``) except ``__init__`` and ``__del__`` and reflection
capabilities (e.g. ``__dict__``).

Most existing standard library modules are not RPython, except for
some functions in ``os``, ``math`` and ``time`` that are natively
supported. In general it is quite unlikely that an existing Python
program is by chance RPython, mostly it has to be rewritten heavily.
To read more about RPython limitations read `RPython description`_

.. _`RPython description`: coding-guide.html#restricted-python


--------------------------------------------------------------------------
What do you mean by "full program"? All the code in all the modules I use?
--------------------------------------------------------------------------

"Full program" in the context of "being RPython" is all the code reachable from
an "entry point" function. The translation toolchain follows all calls
recursively and discovers what belongs to the program and what not.

------------------------------------------------------
What's the ``"NOT_RPYTHON"`` I see in some docstrings?
------------------------------------------------------

If you put "NOT_RPYTHON" into the docstring of a function and that function is
found while trying to translate an RPython program, the translation process
stops and reports this as an error. You can therefore mark functions as
"NOT_RPYTHON" to make sure that they are never analyzed.


-------------------------------------------------------------------
Couldn't we simply take a Python syntax tree and turn it into Lisp?
-------------------------------------------------------------------

It's not necessarily nonsense, but it's not really The PyPy Way.  It's
pretty hard, without some kind of type inference, to translate, say this
Python::

    a + b

into anything significantly more efficient than this Common Lisp::

    (py:add a b)

And making type inference possible is what RPython is all about.

You could make ``#'py:add`` a generic function and see if a given CLOS
implementation is fast enough to give a useful speed (but I think the
coercion rules would probably drive you insane first).  -- mwh

--------------------------------------------
Do I have to rewrite my programs in RPython?
--------------------------------------------

No.  PyPy always runs your code in its own interpreter, which is a full
and compliant Python 2.4 interpreter.  RPython_ is only the language in
which parts of PyPy itself are written.  XXX

-------------------------
Which backends are there?
-------------------------

Backends that can actually translate all of PyPy:

 * C_, LLVM_, CLI_

Somewhat mature backends:

* Low level backends: C_, LLVM_
* High level backends: CLI_, JVM_, JavaScript_

Partially implemented backends:

* Squeak_, `Common Lisp`_


To learn more about backends take a look at the `translation document`_

.. _CLI: cli-backend.html
.. _JavaScript: js/whatis.html
.. _C: translation.html#the-c-back-end
.. _LLVM: translation.html#the-llvm-back-end
.. _`translation document`: translation.html
.. _JVM: translation.html#genjvm
.. _Squeak: translation.html#gensqueak
.. _`Common Lisp`: translation.html#gencl

-------------------------------------------------------
Are there other projects that need the PyPy tool chain?
-------------------------------------------------------

XXX

----------------------
How do I compile PyPy?
----------------------

See the `getting-started`_ guide.  Note that at the moment this produces
an executable that contains a lot of things that are hard-coded for your
particular system (including paths and other stuff), so it's not
suitable for being installed or redistributed.    XXX

---------------------------------
How do I compile my own programs?
---------------------------------

Start from the example of
`pypy/translator/goal/targetnopstandalone.py`_, which you compile by
typing::

    python translate.py targetnopstandalone

You can have a look at intermediate C source code, which is (at the
moment) put in ``/tmp/usession-*/testing_1/testing_1.c``.  Of course,
all the function and stuff indirectly used by your ``entry_point()``
function has to be RPython_.     XXX

--------------------------------------------
Why isn't there a simpler way of doing that?
--------------------------------------------

One answer is that "officially speaking" supporting this is not a goal
of the PyPy project.

XXX

A better answer might be that when the target of compilation turns out
not to be RPython, working out *why* can be very difficult, and
working on the annotator to make these messages clearer -- even if
possible -- would take time away from other development tasks.

It's not that writing RPython is difficult, but if there was some kind
of rpythonc compiling tool there would be much more temptation to try
to compile arbitrary, pre-existing Python programs and this is fairly
unlikely to work (to start, there is very little in the way of an
"RPython standard library"). XXX outdated


---------------------------------------------------------------------------
What does the error message "slice start must be proven non-negative" mean?
---------------------------------------------------------------------------

XXX



.. _`RPython`: coding-guide.html#rpython
.. _`getting-started`: getting-started.html

.. include:: _ref.txt
