============================================================
       Compiling dynamic language implementations
============================================================


The analysis of dynamic languages
===============================================

Dynamic languages are definitely not new on the computing scene.  
However, new conditions like increased computing power and designs driven
by larger communities have enabled the emergence of new aspects in the
recent members of the family, or at least made them more practical than
they previously were.  The following aspects in particular are typical not
only of Python but of most modern dynamic languages:

* The driving force is not minimalistic elegance.  It is a balance between
  elegance and practicality, and rather un-minimalistic -- the feature
  sets built into languages tend to be relatively large and growing
  (to some extent, depending on the language).

* High abstractions and theoretically powerful low-level primitives are
  generally ruled out in favor of a larger number of features that try to
  cover the most common use cases.  In this respect, one could even regard
  these languages as mere libraries on top of some simpler (unspecified)
  language.

* Implementation-wise, language design is no longer driven by a desire to
  enable high performance; any feature straightforward enough to achieve
  with an interpreter is candidate.  As a result, compilation and most
  kinds of static inference are made impossible due to this dynamism
  (unless they are simply tedious due to the size of the language).


No Declarations
--------------------------

The notion of "declaration", central in compiled languages, is entirely
missing in Python.  There is no aspect of a program that must be declared;
the complete program is built and run by executing statements.  Some of
these statements have a declarative look and feel; for example, some
appear to be function or class declarations.  Actually, they are merely
statements that, when executed, build a function or class object.  A
reference to the new object is then stored in a namespace from where it
can be accessed.  Units of programs -- modules, whose source is one
file each -- are similarily mere objects in memory, built on demand by some
other module executing an ``import`` statement.  Any such statement --
class construction or module import -- can be executed at any time during
the execution of a program.

This point of view should help explain why an analysis of a program is
theoretically impossible: there is no declared structure.  The program
could for example build a class in completely different ways based on the
results of NP-complete computations or external factors.  This is not just
a theoretical possibility but a regularly used feature: for example, the
pure Python module ``os.py`` provides some OS-independent interface to
OS-specific system calls, by importing internal OS-specific modules and
completing it with substitute functions, as needed by the OS on which
``os.py`` turns out to be executed.  Many large Python projects use custom
import mechanisms to control exactly how and from where each module is
loaded, by tampering with import hooks or just emulating parts of the
``import`` statement manually.

In addition, there are of course classical (and only partially true)
arguments against compiling dynamic languages (there is an ``eval``
function that can execute arbitrary code, and introspection can change
anything at run-time), but we consider the argument outlined above as more
fundamental to the nature of dynamic languages.


The analysis of live programs
-----------------------------------

How can we perform some static analysis on a program written in a dynamic
language while keeping to the spirit of `No Declarations`_, i.e. without
imposing that the program be written in a static way in which these
declarative-looking statements would actually *be* declarations?

The approach of PyPy is, first of all, to perform analysis on live
programs in memory instead of dead source files.  This means that the
program to analyse is first fully imported and initialized, and once it
has reached a state that is deemed advanced enough, we limit the amount of
dynamism that is allowed *after this point* and we analyse the program's
objects in memory.  In some sense, we use the full Python as a
preprocessor for a subset of the language, called RPython.  Informally,
RPython is Python without the operations and effects that are not supported
by our analysis toolchain (e.g. class creation, and most non-local effects).

Of course, putting more efforts into the toolchain would allow us to
support a larger subset of Python.  We do not claim that our toolchain --
which we describe in the sequel of this paper -- is particularly advanced.
To make our point, let us assume a given an analysis tool, which supports
a given subset of a language.  Then:

* Analysing dead source files is equivalent to giving up all dynamism
  (as far as unsupported by this tool).  This is natural in the presence of
  static declarations.

* Analysing a frozen memory image of a program that we loaded and
  initialized is equivalent to giving up all dynamic after a certain point
  in time.  This is natural in image-oriented environments like Smalltalk,
  where the program resides in memory and not in files in the first place.

Our approach goes further and analyses *live* programs in memory:
the program is allowed to contain fully dynamic sections, as long as these
sections are entered a *bounded* number of times.
For example, the source code of the PyPy
interpreter, which is itself written in this bounded-dynamism style, makes
extensive use of the fact that it is possible to build new classes at any
point in time -- not just during an initialization phase -- as long as this
number of bounded.  E.g. `interpreter/gateway.py`_ builds a custom class
for each function that some variable can point to.  There is a finite
number of functions in total, so this can obviously only create
a finite number of extra classes.  But the precise set of functions that
need a corresponding class is difficult to manually compute in advance;
instead, the code that builds and cache a new class is invoked by the
analysis tool itself each time it discovers that a new function object can
reach the corresponding point.

This approach is derived from dynamic analysis techniques that can support
unrestricted dynamic languages by falling back to a regular interpreter for
unsupported features (e.g. Psyco, described in
http://psyco.sourceforge.net/psyco-pepm-a.ps.gz).
The above argumentation should have shown why we think that being similarily
able to fall back to regular interpretation for parts that cannot be
understood is a central feature of the analysis of dynamic languages.


Concrete and abstract interpretation
======================================================

Object Spaces
---------------------------------

The semantics of Python can be roughly divided in two groups: the syntax of
the language, which focuses on control flow aspects, and the object semantics,
which define how various types of objects react to various operations and
methods.  As it is common in all languages of the family, both the
syntactic elements and the object semantics are complex and at times
complicated (as opposed to more classical languages that tend to subsume
one aspect to the other: for example, Lisp's execution semantics are almost
trivial).

This observation led us to the concept of *Object Space*.  An interpreter can
be divided in two non-trivial parts: one for handling compilation to and
interpretation of pseudo-code (control flow aspects) and one implementing
the object library's semantics.  The former, called *bytecode interpreter*,
considers objects as black boxes; any operation on objects requested by the
bytecode is handled over to the object library, called *object space*.
The point of this architecture is, precisely, that neither of these two
components is trivial; separating them explicitely, with a well-defined
interface inbetween, allows each part to be reused independently.  This is
a major flexibility feature of PyPy: we can for example insert proxy object
spaces in front of the real one, like the `Thunk Object Space`_ adding lazy
evaluation of objects.

Note that the term "object space" has already been reused for other
dynamic language implementations, e.g. XXX for Perl 6.


Abstract interpretation
------------------------------

In the sequel of this paper, we will consider another application
of the object space separation.  The analysis we perform in PyPy
is whole-program type inference.  The analysis of the non-dynamic
parts themselves is based on their `abstract interpretation`_.
PyPy has an alternate object space called the `Flow Object Space`_,
whose objects are empty placeholders.  The over-simplified view
is that to analyse a function, we bind its input arguments to such
placeholders, and execute the function -- i.e. let the interpreter follow
its bytecode and invoke the object space for each operations, one by one.  
The Flow object space records each operation when it is issued, and
returns a new placeholder as a result.  At the end, the list of recorded
operations, along with the involved placeholders, gives an assembler-like
view of what the function performs.

The global picture is then to run the program while switching between the
flow object space for static enough functions, and a standard, concrete
object space for functions or initializations requiring the full dynamism.

If the placeholders are endowed with a bit more information, e.g. if they
carry a type information that is propagated to resulting placeholders by
individual operations, then our abstract interpretation simultaneously
performs type inference.  This is, in essence, executing the program while
abstracting out some concrete values and replacing them with the set of
all values that could actually be there.  If the sets are broad enough,
then after some time we will have seen all potential value sets along each
possible code paths, and our program analysis is complete.

An object space is thus an *interpretation domain*; the Flow Object Space
is an *abstract interpretation domain*.  We are thus interpreting the
program while switching dynamically between several abstraction levels.
This is possible because our design allows the *same* interpreter to work
with a concrete or an abstract object space.

Following parts of the program at the abstract level allows us to deduce
general information about the program, and for parts that cannot be analysed
we switch to the concrete level.  The restrictions placed on the program
to statically analyse are that to be crafted in such a way that this process
eventually terminates; from this point of view, more abstract is better (it
covers whole sets of objects in a single pass).  Thus the compromize that
the author of the program to analyse faces are less strong but more subtle
than not using a specific set of dynamic features at all, but using them
sparsingly enough.


The PyPy analysis toolchain
===========================================

The previous sections have developed a theoretical point of view that
differs significantly from what we have implemented, for many reasons.
The devil is in the details.


Flow Object Space
---------------------------------


XXX

In our bytecode-interpreter design evaluation responsibilities are
split between the Object Space, frames and the so-called execution
context. The latter two object kinds are properly part of the
interpretation engine, while the object space implements all
operations on values which are treated as black boxes by the engine.

The Object Space plays the role of a factory for execution contexts,
whose base implementation is supplied by the engine, and exposes hooks
triggered when frames are entered, left and before each bytecode,
allowing to gather a trace of the execution.

Frames have run/resume methods which embed the interpretation loop,
These methods take an execution context invoking the appropriate hooks
at the corresponding situations.

The Flow Object Space in our current design is responsible of
constructing a flow graph for a single function using abstract
interpretation.

Concretely the Flow Space plugs itself in the interpreter as an object
space, and supplying a derived execution context implementation.  It
also wrap a fix-point loop around invocations of the frame resume
method which is forced to execute one single bytecode through
exceptions reaching this loop from the space operations' code and the
specialised execution context.

The domain on which the Flow Space operates comprises variables and
constant objects. They are stored as such in the frame objects without
problems because by design the interpreter engine treat them
neutrally.

The Flow Space can synthesise out of a frame content so called frame
states.  Frame states described the execution state for the frame at a
given point.

The Flow Space constructs the flow graph by creating new blocks in it,
when fresh never-seen state is reached. During construction block in
the graph all have an associated frame state. The Flow Space start
from an empty block with an a frame state corresponding to setup
induced but input arguments in the form of variables and constants to
the analysed function.

When an operation is delegated to the Flow Space by the frame
interpretation loop, either a constant result is produced, in the case
the arguments are constant and the operation doesn't have
side-effects, otherwise the operation is recorded in the current block
and a fresh new variable is returned as result.

When a new bytecode is about to be executed, as signalled by the
bytecode hook, the Flow Space considers the frame state corresponding
to the current frame contents. The Flow Space keeps a mapping between
byecode instructions, as their position, and frame state, block pairs.

A union operation is defined on frame states, only two equal constants
unify to a constant of the same value, all other combination unify
to a fresh new variable.

If some previously associated frame state for the next byecode unifies
with the current state giving some more general state, i.e. an unequal
one, the corresponding block will be reused and reset. Otherwise a new
block is used.

XXX non mergeable data, details
XXX conditionals, multiple pending blocks

XXX termination for "reasonable" terminating programs

Geninterp
~~~~~~~~~

YYY

YYY dynamic merging good for geninterp


Annotator 
---------------------------------

The annotator is the type inference part of our toolchain.  The
annotator infers *types* in the following sense: given a program
considered as a family of control flow graphs, it assigns to each
variable of each graph a so-called *annotation*, which describes what
are the possible run-time objects that this variable will contain.  Note
that in the literature such an annotation is usually called a type, but
we prefer to avoid this terminology to avoid confusion with the Python
notion of the concrete type of an object.  Annotations are sets of
possible values that is not always exactly the set of all objects of a
specific Python type.

We will first expose a simplified, static model of how the annotator
works, and then hint at some differences between the model and the
reality.


Static model
~~~~~~~~~~~~

The annotator can be considered as taking as input a finite family of
functions calling each other, and working mainly on the control flow
graphs of each of these functions as built by the `Flow Object Space`_.
Additionally, for a particular "entry point" function, each input
argument is given a user-specified annotation.

The goal of the annotator is to find the most precise annotation that
can be given to each variable of all control flow graphs while
respecting constrains imposed by the operations in which these variables
are involved.

More precisely, it is usually possible to deduce information about the
result variable of an operation given information about its arguments.
For example, we can say that the addition of two integers must be an
integer.  Most programming languages have this property.  However,
Python -- like many languages not specifically designed with type
inference in mind -- does not possess a type system that allows much
useful information to be derived about variables based on how they are
*used*; only on how they were *produced*.  For example, a number of very
different built-in types can be involved in an addition; the meaning of
the addition and the type of the result depends on the type of the input
arguments.  Merely knowing that a variable will be used in an addition
does not give much information per se.  For this reason, our annotator
works by flowing annotations forward, operation after operation, i.e. by
performing abstract interpretation of the flow graphs.  In a sense, it
is a more naive approach than the one taken by type systems specifically
designed to enable more advanced inference algorithms.  For example,
`Hindley-Milner`_ type inference works in an inside-out direction, by
starting from individual operations and propagating type constrains
outwards.

Naturally, simply propagating annotations forward requires the use of a
fixpoint algorithm in the presence of loops in the flow graphs or in the
inter-procedural call graph.  Indeed, we flow annotations forward from
the beginning of the entry point function into each block, operation
after operation, and follow all calls recursively.  During this process,
each variable along the way gets an annotation.  In various cases,
e.g. when we close a loop, the previously assigned annotations can be
found to be too restrictive.  In this case, we generalize them to allow
for a larger set of possible run-time values, and schedule the block
where they appear for reflowing.  The more general annotations can
generalize the annotations of the results of the variables in the block,
which in turn can generalize the annotations that flow into the
following blocks, and so on.  This process continues until a fixpoint is
reached.

We can consider that all variables are initially assigned the "bottom"
annotation corresponding to an empty set of possible run-time values.
Annotations can only ever be generalized, and the model is simple enough
to show that there is no infinite chain of generalization, so that this
process necessarily terminates, as we will show in the sequel.


Annotation model
~~~~~~~~~~~~~~~~

XXX model and rules

XXX constant propagation

Prebuilt constants
~~~~~~~~~~~~~~~~~~

XXX

Mutable objects
~~~~~~~~~~~~~~~

XXX

Classes and instances
~~~~~~~~~~~~~~~~~~~~~

XXX

Termination
~~~~~~~~~~~

XXX termination + soundness + most-precise-fixpoint-ness + complexity 


Non-static aspects
~~~~~~~~~~~~~~~~~~

XXX specialization (tons of fun)

XXX executing more user program code (idem)

XXX constant propagation to remove bootstrap-only code

XXX termination even with non-static aspects


Code generation: rewriting to low-level operations
--------------------------------------------------

XXX introduction, repr

Low-level type system for C
~~~~~~~~~~~~~~~~~~~~~~~~~~~

XXX

Implementing operations as helpers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

XXX XXX reusing the annotator and specialization

Generating C code
~~~~~~~~~~~~~~~~~

XXX collecting functions and data structures recursively

XXX inserting hand-written C functions for suggested_primitives

XXX messy



.. _architecture: architecture.html
.. _`Thunk Object Space`: objspace.html#the-thunk-object-space
.. _`abstract interpretation`: theory.html#abstract-interpretation
.. _`Flow Object Space`: objspace.html#the-flow-object-space
.. _`Standard Object Space`: objspace.html#the-standard-object-space
.. _Psyco: http://psyco.sourceforge.net/
.. _`Hindley-Milner`: http://en.wikipedia.org/wiki/Hindley-Milner_type_inference

.. include:: _ref.txt
