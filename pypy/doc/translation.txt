=====================
 PyPy - Translation
=====================

.. contents::
.. sectnum::

This document describes the tool chain that we have developed to analyze
and "compile" RPython_ programs (like PyPy itself) to various target
platforms.

.. _RPython: coding-guide.html#restricted-python

It consists of three broad sections: a slightly simplified overview, a
brief introduction to each of the major components of our tool chain and
then a more comprehensive section describing how the pieces fit together.
If you are reading this document for the first time, the Overview_ is
likely to be most useful, if you are trying to refresh your PyPy memory
then the `How It Fits Together`_ is probably what you want.

Overview
========

The job of translation tool-chain is to translate RPython_ programs into an
efficient version of that program for one of various target platforms,
generally one that is considerably lower-level than Python.  It divides
this task into several steps, and the purpose of this document is to
introduce them.

As of the 0.9 release, RPython_ programs can be translated into the following
languages/platforms: C/POSIX, LLVM/POSIX, CLI/.NET, Squeak, Javascript and
Common Lisp (in addition, there's `a backend`_ that translates
`application-level`_ into `interpreter-level`_ code, but this is a special
case in several ways).

.. _`a backend`: geninterp.html
.. _`application-level`: coding-guide.html#application-level
.. _`interpreter-level`: coding-guide.html#interpreter-level


The choice of the target platform affects the process somewhat, but to
start with we describe the process of translating an RPython_ program into
C (which is the default and original target).

Most of the steps in the translation process operate on control flow
graphs, which are produced from functions in the input program, analyzed,
transformed and then translated to the target language.

It is helpful to consider translation as being made up of the following
steps:

1. The complete program is imported, arbitrary run-time initialization can
   be performed.  Once this is done, the program must be present in memory
   as a form that is "static enough" in the sense of RPython_.

2. The Annotator_ performs a global analysis starting from an specified
   entry point to deduce type and other information about what each
   variable can contain at run-time, building flow graphs using the `Flow
   Object Space`_ as it encounters them.

3. The `RPython Typer`_ (or RTyper) uses the high-level information
   inferred by the Annotator to turn the operations in the control flow
   graphs into low-level operations.

4. After RTyping there are two, rather different, `optional
   transformations`_ which can be applied -- the "backend optimizations"
   which are make the resulting program go faster, and the "stackless
   transform" which transforms the program into a form of continuation
   passing style which allows the implementation of coroutines and other
   forms of non-standard control flow.

5. The next step is `preparing the graphs for source generation`_, which
   involves computing the names that the various functions and types in
   the program will have in the final source and applying transformations
   which insert explicit exception handling and memory management
   operations.

6. The `C backend`_ (colloquially known as "GenC") produces a number of C
   source files (as noted above, we are ignoring the other backends for
   now).

7. These source files are compiled to produce an executable.

(although these steps are not quite as distinct as you might think from
this presentation).

There is an `interactive interface`_ called `translatorshell.py`_ to the
translation process which allows you to interactively work through these
stages.

.. _`SSA`: http://en.wikipedia.org/wiki/Static_single_assignment_form
.. _`translator.py`: http://codespeak.net/pypy/dist/pypy/translator/translator.py
.. _`play around`: getting-started.html#trying-out-the-translator
.. _`Flow Object Space`: objspace.html#the-flow-object-space
.. _`control flow graph`: objspace.html#the-flow-model
.. _`Common Lisp`: http://codespeak.net/pypy/dist/pypy/translator/cl/
.. _Pyrex: http://codespeak.net/pypy/dist/pypy/translator/pyrex/
.. _JavaScript: http://codespeak.net/pypy/dist/pypy/translator/js/
.. _Squeak: http://codespeak.net/pypy/dist/pypy/translator/squeak/
.. _CLI: http://codespeak.net/pypy/dist/pypy/translator/cli/
.. _graph: image/translation.pdf
.. _`interactive interface`: getting-started.html#try-out-the-translator
.. _`translatorshell.py`: http://codespeak.net/pypy/dist/pypy/bin/translatorshell.py

The Flow Model
==============

The `Flow Object Space`_ is described in detail in the `document
describing object spaces`_, but as the data structures produced by the
Flow Object Space are the basic data structures of the translation
process, we quickly summarize them here.

All these types are defined in `pypy.objspace.flow.model`_ (which is the
most imported module in the PyPy source base, to reinforce the point).

The flow graph of a function is represented by the class ``FunctionGraph``.
It contains a reference to a collection of ``Block``\ s connected by ``Link``\ s.

A ``Block`` contains a list of ``SpaceOperation``\ s.  Each ``SpaceOperation``
has an ``opname`` and a list of ``args`` and ``result``, which are either
``Variable``\ s or ``Constant``\ s.

We have an extremely useful PyGame viewer, which allows you to visually
inspect the graphs at various stages of the translation process (very
useful to try to work out why things are breaking).  It looks like this:

   .. image:: image/bpnn_update.png

.. _`document describing object spaces`: objspace.html
.. _`pypy.objspace.flow.model`: http://codespeak.net/pypy/dist/pypy/objspace/flow/model.py

.. _Annotator:

The Annotation Pass
===================

We describe briefly below how a control flow graph can be "annotated" to
discover the types of the objects.  This annotation pass is a form of type
inference.  It operates on the control flow graphs built by the Flow
Object Space.

For a more comprehensive description of the annotation process, see
sections XXX of `Compiling Dynamic Language Implementations`_.

The major goal of the annotator is to "annotate" each variable that
appears in a flow graph.  An "annotation" describes all the possible
Python objects that this variable could contain at run-time, based on a
whole-program analysis of all the flow graphs -- one per function.

An "annotation" is an instance of a subclass of ``SomeObject``.  Each
subclass that represents a specific family of objects.

Here is an overview (see ``pypy.annotation.model``):

* ``SomeObject`` is the base class.  An instance of ``SomeObject()``
  represents any Python object, and as such usually means that the input
  program was not fully RPython.

* ``SomeInteger()`` represents any integer.  ``SomeInteger(nonneg=True)``
  represent a non-negative integer (``>=0``).

* ``SomeString()`` represents any string; ``SomeChar()`` a string of
  length 1.

* ``SomeTuple([s1,s2,..,sn])`` represents a tuple of length ``n``.  The
  elements in this tuple are themselves constrained by the given list of
  annotations.  For example, ``SomeTuple([SomeInteger(), SomeString()])``
  represents a tuple with two items: an integer and a string.


The result of the annotation pass is essentially a large dictionary
mapping ``Variable``\ s to annotations.

All the ``SomeXxx`` instances are immutable.  If the annotator needs to
revise its belief about what a Variable can contain, it does so creating a
new annotation, not mutating the existing one.


Mutable Values and Containers
------------------------------

Mutable objects need special treatment during annotation, because
the annotation of contained values needs to be possibly updated to account
for mutation operations, and consequently the annotation information
reflown through the relevant parts of the flow the graphs.

* ``SomeList`` stands for a list of homogeneous type (i.e. all the
  elements of the list are represented by a single common ``SomeXxx``
  annotation).

* ``SomeDict`` stands for a homogeneous dictionary (i.e. all keys have
  the same ``SomeXxx`` annotation, and so have all values).

User-defined Classes and Instances
-----------------------------------

``SomeInstance`` stands for an instance of the given class or any
subclass of it.  For each user-defined class seen by the annotator, we
maintain a ClassDef (``pypy.annotation.classdef``) describing the
attributes of the instances of the class; essentially, a ClassDef gives
the set of all class-level and instance-level attributes, and for each
one, a corresponding ``SomeXxx`` annotation.

Instance-level attributes are discovered progressively as the annotation
progresses.  Assignments like::

   inst.attr = value

update the ClassDef of the given instance to record that the given
attribute exists and can be as general as the given value.

For every attribute, the ClassDef also records all the positions where
the attribute is *read*.  If, at some later time, we discover an
assignment that forces the annotation about the attribute to be
generalized, then all the places that read the attribute so far are
marked as invalid and the annotator will have to restart its analysis
from there.

The distinction between instance-level and class-level attributes is
thin; class-level attributes are essentially considered as initial
values for instance-level attributes.  Methods are not special in this
respect, except that they are bound to the instance (i.e. ``self =
SomeInstance(cls)``) when considered as the initial value for the
instance.

The inheritance rules are as follows: the union of two ``SomeInstance``
annotations is the ``SomeInstance`` of the most precise common base
class.  If an attribute is considered (i.e. read or written) through a
``SomeInstance`` of a parent class, then we assume that all subclasses
also have the same attribute, and that the same annotation applies to
them all (so code like ``return self.x`` in a method of a parent class
forces the parent class and all its subclasses to have an attribute
``x``, whose annotation is general enough to contain all the values that
all the subclasses might want to store in ``x``).  However, distinct
subclasses can have attributes of the same names with different,
unrelated annotations if they are not used in a general way through the
parent class.


.. _`Compiling Dynamic Language Implementations`: dynamic-language-translation.html

.. _`RPython typer`:

The RPython Typer
=================

http://codespeak.net/pypy/dist/pypy/rpython/

The RTyper is the first place where the choice of backend makes a
difference; as outlined above we are assuming that ANSI C is the target.

The RPython Typer is the bridge between the Annotator_ and the code
generator.  The information computed by the annotator is high-level, in
the sense that it describe RPython types like lists or instances of
user-defined classes.

To emit code we need to represent these high-level annotations in the
low-level model of the target language; for C, this means structures and
pointers and arrays.  The Typer both determines the appropriate low-level type
for each annotation and replaces each high-level operation in the control flow
graphs with one or a few low-level operations.  Just like low-level types,
there is only a fairly restricted set of low-level operations, along the lines
of reading or writing from or to a field of a structure.

In theory, this step is optional; a code generator might be able to read
directly the high-level types.  Our experience, however, suggests that this is
very unlikely to be practical.  "Compiling" high-level types into low-level
ones is rather more messy than one would expect and this was the motivation
for making this step explicit and isolated in a single place.  After RTyping,
the graphs only contain operations that already live on the level of the
target language, which makes the job of the code generators much simpler.

For more detailed information, see the `documentation for the RTyper`_.

.. _`documentation for the RTyper`: rtyper.html

Example: Integer operations
---------------------------

Integer operations are make an easy example.  Assume a graph containing the
following operation::

    v3 = add(v1, v2)

annotated::

    v1 -> SomeInteger()
    v2 -> SomeInteger()
    v3 -> SomeInteger()

then obviously we want to type it and replace it with::

    v3 = int_add(v1, v2)

where -- in C notation -- all three variables v1, v2 and v3 are typed ``int``.
This is done by attaching an attribute ``concretetype`` to v1, v2 and v3
(which might be instances of Variable or possibly Constant).  In our model,
this ``concretetype`` is ``pypy.rpython.lltypesystem.lltype.Signed``.  Of
course, the purpose of replacing the operation called ``add`` with
``int_add`` is that code generators no longer have to worry about what kind
of addition (or concatenation maybe?) it means.

.. _`optional transformations`:

The Optional Transformations
============================

Between RTyping and C source generation there are two optional transforms:
the "backend optimizations" and the "stackless transform".

Backend Optimizations
---------------------

Inlining, malloc removal, ...

The Stackless Transform
-----------------------

XXX write this bit

.. or steal it from Carl...

.. _`preparing the graphs for source generation`:

Preparation for Source Generation
=================================

This, perhaps slightly vaguely named, stage is the most recent to appear as a
separate step.  Its job is to make the final implementation decisions before
source generation -- experience has shown that you really don't want to be
doing *any* thinking at the same time as actually generating source code.  For
the C backend, this step does three things:

 - inserts explicit exception handling,

 - inserts explicit memory management operations,

 - decides on the names functions and types will have in the final
   source (this mapping of objects to names is sometimes referred to as
   the "low-level database").

Making Exception Handling Explicit
----------------------------------

XXX

Memory Management Details
-------------------------

Three options:

 - reference counting
 - Boehm GC
 - our own frameworks

Building the Low-Level Database
-------------------------------

XXX

.. _C:
.. _GenC:
.. _`c backend`:

The C Back-End
==============

http://codespeak.net/pypy/dist/pypy/translator/c/

GenC is not really documented at the moment.  The basic principle of creating
code from flow graphs is similar to the `Python back-end`_.  See also
`Generating C code`_ in another draft.

GenC is usually the most actively maintained backend -- everyone working on
PyPy has a C compiler, for one thing -- and is usually where new features are
implemented first.

.. _`Generating C code`: dynamic-language-translation.html#generating-c-code


A Historical Note
=================

As this document has shown, the translation step is divided into more
steps than one might at first expect.  It is certainly divided into more
steps than we expected when the project started; the very first version of
GenC operated on the high-level flow graphs and the output of the
annotator, and even the concept of the RTyper didn't exist yet.  More
recently, the fact that preparing the graphs for source generation
("databasing") and actually generating the source are best considered
separately has become clear.

This process is reflected in the source somewhat; for example, the LLVM
and C backends use different implementations of the graph preparation
code, although there is no real reason for this.


Other backends
==============

.. _LLVM:

The LLVM Back-End
-----------------

http://codespeak.net/pypy/dist/pypy/translator/llvm/

For information on getting started on the LLVM (`low level virtual machine`_)
backend - please see `here`_. 

Similar to the task of GenC, GenLLVM translates a flow graph to low level LLVM
bytecode.  LLVM's memory model is pretty similar to that of GenC's, and so the
LLVM backend uses the same stages of the tool chain -- the annotator, the
RTyper (targeting the low-level type system) and subsequent transformations,
although the final preparations are done by different code (for historical,
rather than fundamental, reasons).

One of the reasons for targeting LLVM bytecodes is that the LLVM tools include
excellent optimizers -- RPython programs, including the Standard Interpreter,
compiled via LLVM are generally faster than when compiled via C.

The LLVM backend is pretty well maintained, although fewer people have the
necessary tools installed so it can take a bit longer to be fixed when a
refactoring causes it to stop working.  It doesn't support all the features of
GenC -- in particular it only supports the Boehm GC.

The LLVM backend would not have been possible without all the people
contributing to PyPy. Carl Friedrich did an amazing amount of groundwork during
the first half of 2005. Carl Friedrich and Holger then initiated a revamped
version based on the new `RPython Typer`_ flow graph. Significant progress was
made during the Gothenburg sprint - and then the following 6 weeks Eric and
Richard worked on it, achieving a standalone executable just prior to the
Heidelberg sprint.  During the Heidelberg sprint Eric and Richard mainly
worked on sharing the backend external code with GenC.

.. _`low level virtual machine`: http://llvm.org/
.. _`here`: getting-started.html#translating-the-flow-graph-to-llvm-code


.. _`Python again`:
.. _`Python back-end`:

The Object-Oriented Backends
----------------------------

All of the OO backends are less mature than the C or LLVM backends.
None can compile all of PyPy yet, but all can compile small examples.

As they are newer than the low-level backends, we can predict the needs of
these backends slightly better, and this is enabling them to share significant
amounts of code, such as the equivalent of the low-level database (XXX
details).

LoopFinder?

.. mention that pretty much all these backends are done by volunteers?

GenCLI
++++++

GenCLI targets the `Common Language Infrastructure`_, the most famous
implementations of which are Microsoft's `.NET`_ and Mono_.

.. _`Common Language Infrastructure`: http://www.ecma-international.org/publications/standards/Ecma-335.htm
.. _`.NET`: http://www.microsoft.com/net/
.. _Mono: http://www.mono-project.com/

It is probably the most advanced of the object oriented backends -- it can
compile our two standard benchmarks, RPyStone (CPython's PyStone benchmark
modified slightly to be RPython) and a RPython version of the common Richards
benchmark.

It is almost entirely the work of Antonio Cuni, who worked on this backend as
part of his Bachelor's thesis and is continuing to work on it as part of
Google's Summer of Code 2006 program.

GenSqueak
+++++++++

GenSqueak translates RPython programs into source that can be run in `Squeak
<http://www.squeak.org/>`__, the free Smalltalk implementation.

It is probably the least complete of the backends listed here.

The first version was written by Bert Freudenberg of Impara GmbH, mostly as a
way of motivating the design of the ootypesystem.  More recently, it has been
worked on by Niklaus Haldimann.

GenJS
+++++

GenJS targets JavaScript, or more properly ECMAScript.

It is a little different to the other backends, in that it is not really a
goal to ever translate the entire PyPy interpreter -- the most important JS
implementations are browsers, and they probably wouldn't be too happy with the
100+ megabyte JavaScript file that would result...

Instead, the goal of GenJS is more directed towards allowing one to write
Ajax_ web applications entirely in Python (the client side would have to be
restricted to RPython_), and this is the subject of Maciej Fijalkowski's
Summer Of Code 2006 project.

.. _Ajax: http://en.wikipedia.org/wiki/AJAX

The first version of GenJS was written by Eric van Riet Paap (Maciej's mentor
for the Summer Of Code project) and now he and Maciej are collaborating on its
further development.

GenCL
+++++

GenCL generates `ANSI Common Lisp`_ source.

.. _`ANSI Common Lisp`: http://www.lisp.org/HyperSpec/FrontMatter/index.html

GenCL is one of the oldest backends -- some version of it has been present
since before revision 2000, long long before any version of the RTyper
existed!  At the Tokyo sprint in April 2006, GenCL was revived and ported to
work on OOTyped graphs.

GenCL has seen work from many people, but the driving force has mostly been
Seo Sanghyeon.

The Interpreter-Level backend
-----------------------------

http://codespeak.net/pypy/dist/pypy/translator/geninterplevel.py

Above, this backend was described as a "special case in several ways".  One of
these ways is that the job it does is specific to PyPy's standard interpreter,
and the other is that it does not even use the annotator -- it works directly
the graphs produced by the Flow Object Space.

See `geninterp's documentation <geninterp.html>`__.

.. _extfunccalls:

External Function Calls
=======================

There are some functions that we don't want to implement in Python for various
reasons (e.g. if they need to make calls into the OS). These can be
implemented by writing backend code by hand that either implements the
functionality itself or calls appropriate libraries.

Of course the annotator does not know what types these functions return so we
need a way to attach fixed annotations to such functions. Additionally for
every such function we need a low level helper function that behaves like the
hand-written backend code so that we can still test a call to such an external
function. 


Annotating external function calls
----------------------------------

All the information about external functions that are important for the
annotation process are written into `pypy/rpython/extfunctable.py`_. There is a
function called ``declare`` that allows to tell the annotator the return type
of these functions and to attach a low level dummy implementation::

    declare(funct, annotation_factory, lowlevel_dummy)

Here ``funct`` is the function that is supposed to be implemented in the
backend, ``annotation_factory`` is a function that returns an appropriate
annotation of the return value (an instance of a primitive type is also ok, so
you can do ``declare(func, int...)``), lowlevel_dummy is a string of the form
``module/ll_function`` that specifies where the low level dummy function is
defined. Here ``module`` means a Python file in `pypy/rpython/module/`_ and
``ll_function`` is a low level function defined in that file.

If the annotator discovers a call to ``func`` it does not try to follow that
call further (even though that might be possible if the function is written in
Python) but annotates it with the given type immediately. The `RPython Typer`_
replaces calls to ``func`` with calls to the function
``module.ll_function``. The backend is supposed to replace calls to functions
to ``module.ll_function`` by whatever code it finds appropriate.

Implementing low level replacement functions in Python
---------------------------------------------------------

The dummy low level replacement functions are there to implement the external
function on the low level. In contrast to the original function they should
take arguments that are of `low-level type`_. Most of the times they are
implemented by calling appropriate low level to high level conversion
functions and then calling the original function again.

.. _`low-level type`: rtyper.html#low-level-type

If the function is supposed to really be implemented by the backend then the
low level function should have an attribute ``.suggested_primitive = True``
attached. If this is not the case the low level function itself will be
translated and used.


Implementing the external functions in the C backend
----------------------------------------------------

When the C-backend produces C code and finds a function call to one of the
dummy functions it replaces the call to it by a call to a function written in
C. This mapping is done in the file `pypy/translator/c/extfunc.py`_. In there
is a dictionary called ``EXTERNALS`` which contains mappings from dummy
functions to strings::

    EXTERNALS = {
        module.ll_function: "LL_c_name_of_function"
        ...
    }

Here ``LL_c_name_of_function`` is the name of the C function that implements
the functionality of the ``module.ll_function``. These C implementation are
found in the directory `pypy/translator/c/src/`_.

It sometimes necessary to access a certain function or type that is written
in Python from the C code you write by hand (for example for constructing the
return value in the correct low level type). This can be a problem because the
C backend mangles names to prevent clashes. To get a certain low level type
under a fixed name the function ``predeclare_common_types`` needs to be
changed. This function is a generator that yields tuples of the form
``('c_name', LLTYPE)``. This makes the genc assign the name ``c_name`` to the
type ``LLTYPE``. Similarly all the function defined in
``predeclare_utility_functions`` are automatically made accessible under their
name in C.

Testing
-------

It's not always trivial to properly test that all the information that is
needed for a given external function is correct. Usually for a given function
you test at least two different things: Once the dummy low level function by
calling it directly. This is usually done in `pypy/rpython/module/test`_ by
just calling the low level function with appropriately constructed arguments
directly. In addition there should be test that actually tries to translate
a function calling the external function to backend code, compile and run
it. This makes sure that the annotator gets the annotation right and that the
backend code is correct. For the C backend this is done in
`pypy/translator/c/test/test_extfunc.py`_. 

Example
-------

To make this clearer the following shows all the relevant pieces that are
needed for implementing os.open. It is implemented in the following way at
interp-level in the `mixed posix module`_::

    def open(space, fname, flag, mode=0777):
        try: 
            fd = os.open(fname, flag, mode)
        except OSError, e: 
            raise wrap_oserror(space, e) 
        return space.wrap(fd)
    open.unwrap_spec = [ObjSpace, str, int, int]


If the annotator tries to annotate this function it will use the declaration
it finds in the file `pypy/rpython/extfunctable.py`_::

    declare(os.open, int , 'll_os/open')

This means that the function returns an int and that the dummy low level
function can be found in `pypy/rpython/module/ll_os.py`_::

    def ll_os_open(fname, flag, mode):
        return os.open(from_rstr(fname), flag, mode)
    ll_os_open.suggested_primitive = True

The ``suggested_primitive`` attribute of the ``ll_os_open`` is set to True,
because it is reasonable that this function is written directly in the backend.
If the C backend encounters a call to ``ll_os_open`` somewhere in the code it
checks the ``EXTERNALS`` table in `pypy/translator/c/extfunc.py`_. The
relevant part for ``os.open`` is::

    from pypy.rpython.module import ll_os
    EXTERNALS = {
        ...
        ll_os.ll_os_open:    'LL_os_open',
        ...
    }

The `LL_os_open` function is implemented in the file
`pypy/translator/c/src/ll_os.h`_:: 

    int LL_os_open(RPyString *filename, int flag, int mode)
    {
            int fd = open(RPyString_AsString(filename), flag, mode);
            if (fd < 0)
                    RPYTHON_RAISE_OSERROR(errno);
            return fd;
    }

One test for all this can be found in
`pypy/translator/c/test/test_extfunc.py`_::

    def test_os_open():
        tmpfile = str(udir.join('test_os_open.txt'))
        def does_stuff():
            fd = os.open(tmpfile, os.O_WRONLY | os.O_CREAT, 0777)
            return fd
        f1 = compile(does_stuff, [])
        fd = f1()
        os.close(fd)
        assert os.path.exists(tmpfile)


.. _`mixed posix module`: ../module/posix/


How It Fits Together
====================

As should be clear by now, the translation tool chain of PyPy is a flexible
and complicated beast, formed from many separate components.

The following image summarizes the various parts of the tool chain as of the
0.9 release, with the default translation to C highlighted:

.. image:: image/pypy-translation-0.9.png
   :align: center

A detail that has not yet been emphasised is the interaction of the
various components.  It makes for a nice presentation to say that
after the annotator has finished the RTyper processes the graphs and
then the exception handling is made explicit and so on, but it's not
entirely true.  For example, the RTyper inserts calls to many
`low-level helpers`_ which must first be annotated, and the GC
transformer can use inlining (one of the `backend optimizations`_) of
some of its small helper functions to improve performance.  The
following picture attempts to summarize the components involved in
perfoming each step of the default translation process:

.. image:: image/translation-detail-0.9.png
   :align: center

.. _`low-level helpers`: glossary.html#low-level-helper

A component not mentioned before is the "MixLevelAnnotator"; it
provides a convenient interface for a "late" (after RTyping)
translation step to declare that it needs to be able to call each of a
collection of functions (which may refer to each other in a mutually
recursive fashion) and annotate and rtype them all at once.

.. include:: _ref.txt
