=================================
What PyPy can do for your objects
=================================

.. contents::
.. sectnum::


Thanks to the `Object Space`_ architecture, there is a kind of feature
that is easy to implement on top of PyPy: namely, any feature that is
based on proxying, extending, changing or otherwise controlling the
behavior of all objects in a running program.

Here is what we implemented so far, in historical order:

* *Thunk Object Space*: lazily computed objects, computing only when an
  operation is performed on them; lazy functions, computing their result
  only if and when needed; and a way to globally replace an object with
  another.

* *Logic Object Space*: logical variables, i.e. placeholder objects
  whose value can be bound once.

* *Taint Object Space*: a soft security system.  Your application cannot
  accidentally compute results based on tainted objects unless it
  explicitly untaint them first.

* *Dump Object Space*: dumps all operations performed on all the objects
  into a large log file.  For debugging your applications.

* *Transparent Proxies Object Space*: adds new objects that behave like
  regular built-in objects (list objects, traceback objects, etc.), but
  completely under the control of the application.


.. _thunk:

The Thunk Object Space
======================

This small object space, meant as a nice example, wraps another object
space (e.g. the standard one) and adds two capabilities: lazily computed
objects (computed only when an operation is performed on them), and
"become", which completely and globally replaces an object with another.

Example usage::

    $ py.py -o thunk
    >>>> from pypymagic import thunk
    >>>> def f():
    ....    print 'computing...'
    ....    return 6*7
    ....
    >>>> x = thunk(f)
    >>>> x
    computing...
    42
    >>>> x
    42
    >>>> y = thunk(f)
    >>>> type(y)
    computing...
    <pypy type 'int'>

A related, but more obscure feature, allows one object to be instantly
and globally replaced with another::

    $ py.py -o thunk
    >>>> from pypymagic import become
    >>>> x = object()
    >>>> lst = [1, 2, x, 4]
    >>>> become(x, 3)
    >>>> lst
    [1, 2, 3, 4]

There is also a decorator for functions whose result can be computed
lazily (the function appears to return a result, but it is not really
invoked before the result is used, if at all)::

    $ py.py -o thunk
    >>>> from pypymagic import lazy
    >>>> @lazy
    .... def f(x):
    ....    print 'computing...'
    ....    return x * 100
    ....
    >>>> lst = [f(i) for i in range(10)]
    >>>> del lst[1:9]
    >>>> lst
    computing...
    computing...
    [0, 900]

The implementation is short (see `pypy/objspace/thunk.py`_).  For the
purpose of ``become()``, it adds an internal field `w_thunkalias` to
each object, which is either None (in the common case) or a reference to
the object that this object was replaced with.  When any space operation
is invoked, the chain of ``w_thunkalias`` references is followed and the
underlying object space really operates on the new objects instead of
the old ones.

For the laziness part, the function ``thunk()`` returns an instance of a
new internal class ``W_Thunk`` which stores the user-supplied callable
and arguments.  When a space operation follows the ``w_thunkalias``
chains of objects, it special-cases ``W_Thunk``: it invokes the stored
callable if necessary to compute the real value and then stores it in
the ``w_thunkalias`` field of the ``W_Thunk``, which has the effect of
replacing the latter with the real value.


.. _logic:

The Logic Object Space
======================

The Logic Object Space adds several logic programming features,
including the notion of logical variable.  A logical variable is really
an object from the Python point of view; it is called "variable" for
consistency with logic programming terminology.  It is an "empty" object
with no initial value at all.  It is possible to put a value into this
object once, and only once, at any point in time.

This is not entierely unrelated to a lazily-computed object, except that
the object has no built-in knowledge about how it should compute itself.
Trying to use such an object before it got a value results in a lock:
the current thread is suspended, in the hope that another thread will
eventually put a value into the object.  In practice, this works well
with microthreads instead of real threads (see `Stackless features`_).

Two somewhat outdated documents describe the Logic Object Space in more
details:

* `How to use the Logic Object space features of PyPy 0.9`_;
* `EU Interim Report`_ (PDF).

The following document is a draft:

* `Ideas about syntactic and algorithmic aspects of Constraint and Logic
  Programming in Python`_

.. _`Ideas about syntactic and algorithmic aspects of Constraint and Logic Programming in Python`: constraints-and-logic.html
.. _`How to use the Logic Object space features of PyPy 0.9`: howto-logicobjspace-0.9.html
.. _`EU Interim Report`: http://codespeak.net/pypy/extradoc/eu-report/D09.1_Constraint_Solving_and_Semantic_Web-interim-2006-07-28.pdf
.. _`Stackless features`: stackless.html


.. _taint:

The Taint Object Space
======================

Motivation
----------

The Taint Object Space provides a form of security: "tainted objects",
inspired by various sources, including Perl's tainting (XXX more
references needed).

The basic idea of this kind of security is not to protect against
malicious code, unlike sandboxing, for example.  The idea is that,
considering a large application that handles sensitive data, there are
typically only a small number of places that need to explicitly
manipulate that sensitive data; all the other places merely pass it
around, or do entierely unrelated things.

Nevertheless, if a large application needs to be reviewed for security,
it must be entierely carefully checked, because it is possible that a
bug at some apparently unrelated place could lead to a leak of sensitive
information in a way that an external attacker could exploit.  For
example, if any part of the application provides web services, an
attacker might be able to issue unexpected requests with a regular web
browser and deduce secret information from the details of the answers he
gets.

An approach like that of the Taint Object Space allows the small parts
of the program that manipulate sensitive data to be explicitly marked.
The effect of this is that although these small parts still need a
careful security review, the rest of the application no longer does,
because even a bug would be unable to leak the information.

We have implemented a simple two-levels model: objects are either
regular (untainted), or hidden (tainted).  It would be simple to extend
the code for more fine-grained scales of secrecy.  For example it is
typical in the literature to consider user-specified lattices of secrecy
levels, corresponding to multiple "owners" that cannot access data
belonging to another "owner" unless explicitly authorized to do so.

Tainting and untainting
-----------------------

Start a py.py with the Taint Object Space and try the following example::

    $ py.py -o taint
    >>>> from pypymagic import taint
    >>>> x = taint(6)

    # x is secret from now on.  We can pass it around and
    # even operate on it, but not inspect it.  Taintness
    # is propagated to operation results.

    >>>> x
    TaintError

    >>>> if x > 5: y = 2
    TaintError

    >>>> y = x + 5       # ok
    >>>> lst = [x, y]
    >>>> z = lst.pop()
    >>>> t = type(z)     # type() works too, tainted answer
    >>>> t
    TaintError
    >>>> u = t is int    # even 'is' works
    >>>> u
    TaintError

Notice that using a tainted boolean like ``x > 5`` in an ``if``
statement is forbidden.  This is because knowing which path is followed
would give away a hint about ``x``; in the example above, if the
statement ``if x > 5: y = 2`` were allowed to run, we would know
something about the value of ``x`` by looking at the (untainted) value
in the variable ``y``.

Of course, there is a way to inspect tainted objects.  The basic way is
to explicitly untaint the object.  In an application, the places that
use this ``untaint()`` declassification function are the places that
need careful security review.  To avoid unexpected objects showing up,
the ``untaint()`` function must be called with the exact type of the
object to declassify.  It will raise ``TaintError`` if the type doesn't
match::

    >>>> from pypymagic import taint
    >>>> untaint(int, x)
    6
    >>>> untaint(int, z)
    11
    >>>> untaint(bool, x > 5)
    True
    >>>> untaint(int, x > 5)
    TaintError


Taint Bombs
-----------

In this area, a common problem is what to do about failing operations.
If an operation raises an exception when manipulating a tainted object,
then the very presence of the exception can leak information about the
tainted object itself.  Consider::

    >>>> 5 / (x-6)

By checking if this raises ``ZeroDivisionError`` or not, we would know
if ``x`` was equal to 6 or not.  The solution to this problem in the
Taint Object Space is to introduce *Taint Bombs*.  They are a kind of
tainted object that doesn't contain a real object, but a pending
exception.  Taint Bombs are undistinguishable from normal tainted
objects to unpriviledged code. See::

    >>>> x = taint(6)
    >>>> i = 5 / (x-6)     # no exception here
    >>>> j = i + 1         # nor here
    >>>> k = j + 5         # nor here
    >>>> untaint(int, k)
    TaintError

In the above example, all of ``i``, ``j`` and ``k`` contain a Taint
Bomb.  Trying to untaint it raises ``TaintError``, but at the point
where ``untaint()`` is called.  This means that all calls to
``untaint()`` must also be carefully reviewed for what occurs if they
receive a Taint Bomb; they might catch the ``TaintError`` and give the
user a generic message that something went wrong, if we are reasonably
careful that the message or even its preserve doesn't give information
away.  This might be a decliate problem by itself, but there is no
satisfying general solution to this problem; it must be considered on a
case-by-case basis.  Again, what the Taint Object Space approach
achieves is not solving these problems, but localizing them to
well-defined small parts of the application - namely, around calls to
``untaint()``.

Note that the ``TaintError`` exception is deliberately not including any
useful error message, because that might give information away too.
However, it makes debugging quite harder.  This is a difficult problem
to solve in general too; so far we implemented a "debug mode" that dumps
information to the low-level stderr of the application (where we hope
that it is unlikely to be seen by anyone else than the application
developer).  The debug mode must be activated with
``pypymagic.taint_debug(1)``.


Taint Atomic functions
----------------------

Occasionally, a more complicated computation must be performed on a
tainted object.  This requires first untainting the object, perform the
computations, and then carefully taint the result again (including
hiding all exceptions that could give information away).

There is a built-in decorator that does exactly that::

    >>>> @pypymagic.taint_atomic
    >>>> def myop(x, y):
    ....     while x > 0:
    ....         x -= y
    ....     return x
    ....
    >>>> myop(42, 10)
    -8
    >>>> z = myop(taint(42), 10)
    >>>> z
    TaintError
    >>>> untaint(int, z)
    -8

The decorator makes a whole function behave like a built-in operation.
If no tainted argument is passed in, the function behaves normally.  But
if any of the arguments is tainted, it is automatically untainted - so
the function body always sees untainted arguments - and the eventual
result is tainted again (possibly in a Taint Bomb).

It is important for the function marked as ``taint_atomic`` to have no
visible side effects, otherwise information could be leaked that way.
This is currently not enforced, which means that all ``taint_atomic``
functions have to be carefully reviewed for security (but not the
callers of ``taint_atomic`` functions).

A possible future extension would be to forbid side-effects on
non-tainted objects from all ``taint_atomic`` functions.

An example of usage: given a tainted object ``passwords_db`` that
references a database of passwords, we can write a function
that checks if a password is valid as follows::

    @taint_atomic
    def validate(passwords_db, username, password):
        assert type(passwords_db) is PasswordDatabase
        assert type(username) is str
        assert type(password) is str
        ...load username entry from passwords_db...
        return expected_password == password

It returns a tainted boolean answer, or a Taint Bomb if something
went wrong.  A caller can do:

    ok = validate(passwords_db, 'john', '1234')
    ok = untaint(bool, ok)

This can give three outcomes: ``True``, ``False``, or a ``TaintError``
exception (with no information on it) if anything went wrong.  If even
this is considered giving too much information away, the ``False`` case
can be made indistinguishable from the ``TaintError`` case (simply by
also raising an exception in ``validate()`` if the password is wrong).

In the above example, the security achieved is that as long as
``validate()`` does not leak information, no other part of the code can
obtain more information about a passwords database than a Yes/No answer
to a precise query.

A possible extension of the ``taint_atomic`` decorator would be to check
the argument types as ``untaint()`` does, for the same reason - to
prevent bugs where a function like ``validate()`` above is accidentally
called with the wrong kind of object, and thus leaks information about
it.  For now, all ``taint_atomic`` function should be conservative and
carefully check all assumptions on all input arguments.


Interface
---------

.. _`like a built-in operation`:

The basic rule of the Tainted Object Space is that it introduces two new
kinds of objects, Tainted Boxes and Tainted Bombs (which are not types
in the Python sense).  Each box internally contains a regular object;
each bomb internally contains an exception object.  An operation
involving Tainted Boxes is performed on the objects contained in the
boxes, and give a Tainted Box or a Tainted Bomb as a result (such an
operation does not let an exception be raised).  An operation called
with a Tainted Bomb argument immediately returns the same Tainted Bomb.

In a PyPy running with (or translated with) the Taint Object Space,
the ``pypymagic`` module exposes the following interface:

* ``taint(obj)``

    Return a new Tainted Box wrapping ``obj``.  Return ``obj`` itself
    if it is already tainted (a Box or a Bomb).

* ``is_tainted(obj)``

    Check if ``obj`` is tainted (a Box or a Bomb).

* ``untaint(type, obj)``

    Untaints ``obj`` if it is tainted.  Raise ``TaintError`` if the type
    of the untainted object is not exactly ``type``, or if ``obj`` is a
    Bomb.

* ``taint_atomic(func)``

    Return a wrapper function around the callable ``func``.  The wrapper
    behaves `like a built-in operation`_ with respect to untainting the
    arguments, tainting the result, and returning a Bomb.

* ``TaintError``

    Exception.  On purpose, it provides no attribute or error message.

* ``_taint_debug(level)``

    Set the debugging level to ``level`` (0=off).  At level 1 or above,
    all Taint Bombs print a diagnostic message to stderr when they are
    created.

* ``_taint_look(obj)``

    For debugging purposes: prints (to stderr) the type and address of
    the object in a Tainted Box, or prints the exception if ``obj`` is
    a Taint Bomb.


.. _dump:

The Dump Object Space
=====================

XXX


.. _tproxy:

Transparent Proxy Implementation
================================

Among the unique features of PyPy, there is as well the possibility of
having multiple implementations of builtin types. Multiple performance
optimisations using this features are already implemented, some 
hints are in the `Object Space`_ document.

Transparent proxy are implementations of some (maybe all at some point)
objects like functions, objects, lists etc. which forwards all
operations performed on these object to app-level functions which have specific
signatures.

.. _`Object Space`: objspace.html#object-types

Example:
---------

Suppose we want to have list which stores all operations performed on
it for later analysis. So we create an apropriate controller::

    from pypymagic import transparent_proxy
   
    class Controller(object):
        def __init__(self, l):
            self.l = l
            self.history = []
        def perform(self, name, *args, **kwargs):
            self.history.append(name)
            return getattr(self.l, name)(*args, **kwargs)
    l = []
    c = Controller(l)
    lst = transparent_proxy(list, c.perform)

Here, we've created original list, some random class and called a magic
``transparent_proxy`` function, which takes an type and a function which will be
called on every operation on the result of the ``transparent_proxy`` call.
The arguments of such a call are the operation name and additional 
arguments.

The important bit is that we do not need some existing object to perform
operations on, it can do whatever we like. And of course 
``type(lst) is type(l)`` and ``lst is not l`` (well, the latter is not
"of course", but actually it's true).

Now we can access all the history of operations on the list in ``c.history``.
Example::

    >>>> lst
    []
    >>>> type(lst)
    <type 'list'>
    >>>> lst.append(3)
    >>>> lst
    [3]
    >>>> lst[-1]
    3
    >>>> c.history
    ['__repr__', '__getattribute__', '__repr__', '__getitem__']

Note that ``append`` shows up as ``__getattribute__`` and that the ``type(lst)``
does not show up at all (indeed the type is the only aspect of the instance that
the controller cannot change).

Further points of interest:
---------------------------

A lot of tasks could be performed using transparent proxies. Including,
but not limited to:

* A Remote version of objects, on which we perform operations
  (think about transparent distribution)

* Access to some persistent-storages like databases (imagine an
  SQL object mapper which looks like real object)

* Access to external data structures, like other languages as normal
  objects. (Of course some operations on them could raise exceptions, but it's
  purely done in application level, so it's not real problem)

Random notes:
-------------

Transparent proxy is implemented on top of `standard object space`_, in
`proxy_helpers.py`_, `proxyobject.py`_ and `transparent.py`_. To run it
you need to pass ``--with-transparent-proxy`` option to ``py.py`` or
``translate.py``. It registers implementations like a ``W_TransparentXxx``
which usually corresponds to an apropriate ``W_XxxObject``, including some
interpreter hacks for objects that are too close to the interpreter
to be implemented in a std objspace. The types of objects that can be proxied
like this are:
user created classes & functions, lists, dicts, exceptions, tracebacks and
frames.

.. _`standard object space`: objspace.html#the-standard-object-space
.. _`proxy_helpers.py`: http://codespeak.net/svn/pypy/dist/pypy/objspace/std/proxy_helpers.py
.. _`proxyobject.py`: http://codespeak.net/svn/pypy/dist/pypy/objspace/std/proxyobject.py
.. _`transparent.py`: http://codespeak.net/svn/pypy/dist/pypy/objspace/std/transparent.py

.. include:: _ref.txt
