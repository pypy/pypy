=================================
What PyPy can do for your objects
=================================

.. contents::
.. sectnum::


Thanks to the `Object Space`_ architecture, there is a kind of feature
that is easy to implement on top of PyPy: namely, any feature that is
based on proxying, extending, changing or otherwise controlling the
behavior of all objects in a running program.

Here is what we implemented so far, in historical order:

* *Thunk Object Space*: lazily computed objects, computing only when an
  operation is performed on them; lazy functions, computing their result
  only if and when needed; and a way to globally replace an object with
  another.

* *Logic Object Space*: logical variables, i.e. placeholder objects
  whose value can be bound once.

* *Taint Object Space*: a soft security system.  Your application cannot
  accidentally compute results based on tainted objects unless it
  explicitly untaint them first.

* *Dump Object Space*: dumps all operations performed on all the objects
  into a large log file.  For debugging your applications.

* *Transparent Proxies Object Space*: adds new objects that behave like
  regular built-in objects (list objects, traceback objects, etc.), but
  completely under the control of the application.

Which object space to use can be chosen with :config:`objspace.name` option.

.. _`Object Space`: objspace.html

.. _thunk:

The Thunk Object Space
======================

This small object space, meant as a nice example, wraps another object
space (e.g. the standard one) and adds two capabilities: lazily computed
objects (computed only when an operation is performed on them), and
"become", which completely and globally replaces an object with another.

Example usage::

    $ py.py -o thunk
    >>>> from pypymagic import thunk
    >>>> def f():
    ....    print 'computing...'
    ....    return 6*7
    ....
    >>>> x = thunk(f)
    >>>> x
    computing...
    42
    >>>> x
    42
    >>>> y = thunk(f)
    >>>> type(y)
    computing...
    <type 'int'>

A related, but more obscure feature, allows one object to be instantly
and globally replaced with another::

    $ py.py -o thunk
    >>>> from pypymagic import become
    >>>> x = object()
    >>>> lst = [1, 2, x, 4]
    >>>> become(x, 3)
    >>>> lst
    [1, 2, 3, 4]

There is also a decorator for functions whose result can be computed
lazily (the function appears to return a result, but it is not really
invoked before the result is used, if at all)::

    $ py.py -o thunk
    >>>> from pypymagic import lazy
    >>>> @lazy
    .... def f(x):
    ....    print 'computing...'
    ....    return x * 100
    ....
    >>>> lst = [f(i) for i in range(10)]
    >>>> del lst[1:9]
    >>>> lst
    computing...
    computing...
    [0, 900]

The implementation is short (see `pypy/objspace/thunk.py`_).  For the
purpose of ``become()``, it adds an internal field `w_thunkalias` to
each object, which is either None (in the common case) or a reference to
the object that this object was replaced with.  When any space operation
is invoked, the chain of ``w_thunkalias`` references is followed and the
underlying object space really operates on the new objects instead of
the old ones.

For the laziness part, the function ``thunk()`` returns an instance of a
new internal class ``W_Thunk`` which stores the user-supplied callable
and arguments.  When a space operation follows the ``w_thunkalias``
chains of objects, it special-cases ``W_Thunk``: it invokes the stored
callable if necessary to compute the real value and then stores it in
the ``w_thunkalias`` field of the ``W_Thunk``, which has the effect of
replacing the latter with the real value.


.. _logic:

The Logic Object Space
======================

The Logic Object Space adds several logic programming features,
including the notion of logical variable.  A logical variable is really
an object from the Python point of view; it is called "variable" for
consistency with logic programming terminology.  It is an "empty" object
with no initial value at all.  It is possible to put a value into this
object once, and only once, at any point in time.

This is not entirely unrelated to a lazily-computed object, except that
the object has no built-in knowledge about how it should compute itself.
Trying to use such an object before it got a value results in a lock:
the current thread is suspended, in the hope that another thread will
eventually put a value into the object.  In practice, this works well
with microthreads instead of real threads (see `Stackless features`_).

The `EU Interim Report`_ (PDF) describes the Logic Object Space in
more details.

.. _`EU Interim Report`: http://codespeak.net/pypy/extradoc/eu-report/D09.1_Constraint_Solving_and_Semantic_Web-interim-2006-07-28.pdf
.. _`Stackless features`: stackless.html

.. _taint:

The Taint Object Space
======================

Motivation
----------

The Taint Object Space provides a form of security: "tainted objects",
inspired by various sources, including Perl's tainting (XXX more
references needed).

The basic idea of this kind of security is not to protect against
malicious code, unlike sandboxing, for example.  This is about the
handling of "sensitive" data.  It covers two kinds of sensitive data:
secret data which should not leak, and untrusted data coming from an
external source and that must be validated before it is used.

The idea is that, considering a large application that handles these
kinds of sensitive data, there are typically only a small number of
places that need to explicitly manipulate that sensitive data; all the
other places merely pass it around, or do entirely unrelated things.

Nevertheless, if a large application needs to be reviewed for security,
it must be entirely carefully checked, because it is possible that a
bug at some apparently unrelated place could lead to a leak of sensitive
information in a way that an external attacker could exploit.  For
example, if any part of the application provides web services, an
attacker might be able to issue unexpected requests with a regular web
browser and deduce secret information from the details of the answers he
gets.  Another example is the common CGI attack where an attacker sends
malformed inputs and causes the CGI script to do unintended things.

An approach like that of the Taint Object Space allows the small parts
of the program that manipulate sensitive data to be explicitly marked.
The effect of this is that although these small parts still need a
careful security review, the rest of the application no longer does,
because even a bug would be unable to leak the information.

We have implemented a simple two-levels model: objects are either
regular (untainted), or sensitive (tainted).  Objects are marked as
sensitive if they are secret or untrusted, and only declassified at
carefully-checked positions (e.g. where the secret data is needed, or
after the untrusted data has been fully validated).

It would be simple to extend the code for more fine-grained scales of
secrecy.  For example it is typical in the literature to consider
user-specified lattices of secrecy levels, corresponding to multiple
"owners" that cannot access data belonging to another "owner" unless
explicitly authorized to do so.

Tainting and untainting
-----------------------

Start a py.py with the Taint Object Space and try the following example::

    $ py.py -o taint
    >>>> from pypymagic import taint
    >>>> x = taint(6)

    # x is hidden from now on.  We can pass it around and
    # even operate on it, but not inspect it.  Taintness
    # is propagated to operation results.

    >>>> x
    TaintError

    >>>> if x > 5: y = 2   # see below
    TaintError

    >>>> y = x + 5         # ok
    >>>> lst = [x, y]
    >>>> z = lst.pop()
    >>>> t = type(z)       # type() works too, tainted answer
    >>>> t
    TaintError
    >>>> u = t is int      # even 'is' works
    >>>> u
    TaintError

Notice that using a tainted boolean like ``x > 5`` in an ``if``
statement is forbidden.  This is because knowing which path is followed
would give away a hint about ``x``; in the example above, if the
statement ``if x > 5: y = 2`` was allowed to run, we would know
something about the value of ``x`` by looking at the (untainted) value
in the variable ``y``.

Of course, there is a way to inspect tainted objects.  The basic way is
to explicitly "declassify" it with the ``untaint()`` function.  In an
application, the places that use ``untaint()`` are the places that need
careful security review.  To avoid unexpected objects showing up, the
``untaint()`` function must be called with the exact type of the object
to declassify.  It will raise ``TaintError`` if the type doesn't match::

    >>>> from pypymagic import taint
    >>>> untaint(int, x)
    6
    >>>> untaint(int, z)
    11
    >>>> untaint(bool, x > 5)
    True
    >>>> untaint(int, x > 5)
    TaintError


Taint Bombs
-----------

In this area, a common problem is what to do about failing operations.
If an operation raises an exception when manipulating a tainted object,
then the very presence of the exception can leak information about the
tainted object itself.  Consider::

    >>>> 5 / (x-6)

By checking if this raises ``ZeroDivisionError`` or not, we would know
if ``x`` was equal to 6 or not.  The solution to this problem in the
Taint Object Space is to introduce *Taint Bombs*.  They are a kind of
tainted object that doesn't contain a real object, but a pending
exception.  Taint Bombs are undistinguishable from normal tainted
objects to unpriviledged code. See::

    >>>> x = taint(6)
    >>>> i = 5 / (x-6)     # no exception here
    >>>> j = i + 1         # nor here
    >>>> k = j + 5         # nor here
    >>>> untaint(int, k)
    TaintError

In the above example, all of ``i``, ``j`` and ``k`` contain a Taint
Bomb.  Trying to untaint it raises an exception - a generic
``TaintError``.  What we win is that the exception gives little away,
and most importantly it occurs at the point where ``untaint()`` is
called, not where the operation failed.  This means that all calls to
``untaint()`` - but not the rest of the code - must be carefully
reviewed for what occurs if they receive a Taint Bomb; they might catch
the ``TaintError`` and give the user a generic message that something
went wrong, if we are reasonably careful that the message or even its
presence doesn't give information away.  This might be a decliate
problem by itself, but there is no satisfying general solution to this
problem; it must be considered on a case-by-case basis.  Again, what the
Taint Object Space approach achieves is not solving these problems, but
localizing them to well-defined small parts of the application - namely,
around calls to ``untaint()``.

Note that the ``TaintError`` exception is deliberately not including any
useful error message, because that might give information away too.
However, it makes debugging quite harder.  This is a difficult problem
to solve in general too; so far we implemented a way to peek in a Taint
Box or Bomb, ``pypymagic._taint_look(x)``, and a "debug mode" that
prints the exception as soon as a Bomb is created.  Both write
information to the low-level stderr of the application, where we hope
that it is unlikely to be seen by anyone else than the application
developer.


Taint Atomic functions
----------------------

Occasionally, a more complicated computation must be performed on a
tainted object.  This requires first untainting the object, perform the
computations, and then carefully tainting the result again (including
hiding all exceptions into Bombs).

There is a built-in decorator that does exactly that::

    >>>> @pypymagic.taint_atomic
    >>>> def myop(x, y):
    ....     while x > 0:
    ....         x -= y
    ....     return x
    ....
    >>>> myop(42, 10)
    -8
    >>>> z = myop(taint(42), 10)
    >>>> z
    TaintError
    >>>> untaint(int, z)
    -8

The decorator makes a whole function behave like a built-in operation.
If no tainted argument is passed in, the function behaves normally.  But
if any of the arguments is tainted, it is automatically untainted - so
the function body always sees untainted arguments - and the eventual
result is tainted again (possibly in a Taint Bomb).

It is important for the function marked as ``taint_atomic`` to have no
visible side effects, otherwise information could be leaked that way.
This is currently not enforced, which means that all ``taint_atomic``
functions have to be carefully reviewed for security (but not the
callers of ``taint_atomic`` functions).

A possible future extension would be to forbid side-effects on
non-tainted objects from all ``taint_atomic`` functions.

An example of usage: given a tainted object ``passwords_db`` that
references a database of passwords, we can write a function
that checks if a password is valid as follows::

    @taint_atomic
    def validate(passwords_db, username, password):
        assert type(passwords_db) is PasswordDatabase
        assert type(username) is str
        assert type(password) is str
        ...load username entry from passwords_db...
        return expected_password == password

It returns a tainted boolean answer, or a Taint Bomb if something
went wrong.  A caller can do::

    ok = validate(passwords_db, 'john', '1234')
    ok = untaint(bool, ok)

This can give three outcomes: ``True``, ``False``, or a ``TaintError``
exception (with no information on it) if anything went wrong.  If even
this is considered giving too much information away, the ``False`` case
can be made indistinguishable from the ``TaintError`` case (simply by
raising an exception in ``validate()`` if the password is wrong).

In the above example, the security results achieved are the following:
as long as ``validate()`` does not leak information, no other part of
the code can obtain more information about a passwords database than a
Yes/No answer to a precise query.

A possible extension of the ``taint_atomic`` decorator would be to check
the argument types, as ``untaint()`` does, for the same reason: to
prevent bugs where a function like ``validate()`` above is accidentally
called with the wrong kind of tainted object, which would make it
misbehave.  For now, all ``taint_atomic`` functions should be
conservative and carefully check all assumptions on their input
arguments.


Interface
---------

.. _`like a built-in operation`:

The basic rule of the Tainted Object Space is that it introduces two new
kinds of objects, Tainted Boxes and Tainted Bombs (which are not types
in the Python sense).  Each box internally contains a regular object;
each bomb internally contains an exception object.  An operation
involving Tainted Boxes is performed on the objects contained in the
boxes, and give a Tainted Box or a Tainted Bomb as a result (such an
operation does not let an exception be raised).  An operation called
with a Tainted Bomb argument immediately returns the same Tainted Bomb.

In a PyPy running with (or translated with) the Taint Object Space,
the ``pypymagic`` module exposes the following interface:

* ``taint(obj)``

    Return a new Tainted Box wrapping ``obj``.  Return ``obj`` itself
    if it is already tainted (a Box or a Bomb).

* ``is_tainted(obj)``

    Check if ``obj`` is tainted (a Box or a Bomb).

* ``untaint(type, obj)``

    Untaints ``obj`` if it is tainted.  Raise ``TaintError`` if the type
    of the untainted object is not exactly ``type``, or if ``obj`` is a
    Bomb.

* ``taint_atomic(func)``

    Return a wrapper function around the callable ``func``.  The wrapper
    behaves `like a built-in operation`_ with respect to untainting the
    arguments, tainting the result, and returning a Bomb.

* ``TaintError``

    Exception.  On purpose, it provides no attribute or error message.

* ``_taint_debug(level)``

    Set the debugging level to ``level`` (0=off).  At level 1 or above,
    all Taint Bombs print a diagnostic message to stderr when they are
    created.

* ``_taint_look(obj)``

    For debugging purposes: prints (to stderr) the type and address of
    the object in a Tainted Box, or prints the exception if ``obj`` is
    a Taint Bomb.


.. _dump:

The Dump Object Space
=====================

When PyPy is run with (or translated with) the Dump Object Space, all
operations between objects are dumped to a file called
``pypy-space-dump``.  This should give a powerful way to debug
applications, but so far the dump can only be inspected in a text
editor; better browsing tools are needed before it can be really useful.

Try::

    $ py.py -o dump
    >>>> 2+3
    5
    >>>> (exit py.py here)
    $ more pypy-space-dump

On my machine the ``add`` between 2 and 3 starts at line 3152 (!)  and
returns at line 3164.  All the rest is start-up, printing, and shutdown.


.. _tproxy:

Transparent Proxy Implementation
================================

Among the unique features of PyPy, there is as well the possibility of
having multiple implementations of builtin types. Multiple performance
optimisations using this features are already implemented, see the document
about `alternative object implementations`_.

Transparent proxies are implementation of types which sends every performed
operation on an object to a provided callable. From an application level
it looks like an instance of arbitrary type, but all operations are directly
calling a provided callable with an apropriate arguments.

Suppose we have a need of having a list instance which added to anything
will provide 42. Than we create transparent proxy for int::

   $ py.py --with-transparent-proxy
   >>>> from pypymagic import transparent_proxy
   >>>> def f(operation, *args, **kwargs):
   >>>>    if operation == '__add__':
   >>>>         return 42
   >>>>    raise AttributeError
   >>>>
   >>>> i = transparent_proxy(list, f)

And now::

   >>> type(i)
   list
   >>> i + 3
   42

.. _`alternative object implementations`: object-optimizations.html

More sophisticated example:
---------------------------

Suppose we want to have list which stores all operations performed on
it for later analysis. So we create an apropriate controller::

    >>>> from pypymagic import transparent_proxy
    >>>> class Controller(object):
    >>>>    def __init__(self, l):
    >>>>        self.l = l
    >>>>        self.history = []
    >>>>    def perform(self, name, *args, **kwargs):
    >>>>        self.history.append(name)
    >>>>        return getattr(self.l, name)(*args, **kwargs)
    >>>> l = []
    >>>> c = Controller(l)
    >>>> lst = transparent_proxy(list, c.perform)

Now we can perform::

    >>>> lst.append(3)
    >>>> len(lst)
    1
    >>>> l
    [3]
    >>>> c.history
    [__getattribute__, __len__]
    >>>> type(lst) is type(l)
    True

So what happened:

* We've create transparent proxy of type list with controller c.perform

* When performing lst.append, it calls lst.__getattribute__ which returns
  bound method append of l (so append did not show up)

* we call len

* we call type, which does not show up at all (indeed the type is the only
  aspect of the instance that the controller cannot change).

Note that ``append`` shows up as ``__getattribute__`` and that the ``type(lst)``
does not show up at all (indeed the type is the only aspect of the instance that
the controller cannot change).

Provided API:
-------------

Transparent proxy provides two magic functions appearing in the pypymagic module.

* `transparent_proxy` - a basic function to create proxy object.

* `get_transparent_controller` - for some use-cases there is need to know
  when an object is a transparent proxy. This function returns an original controller
  (a callable) or None in case this is a normal Python object. This is
  the only official way of distinguishing transparent objects from normal ones.

Further points of interest:
---------------------------

A lot of tasks could be performed using transparent proxies. Including,
but not limited to:

* A Remote version of objects, on which we perform operations
  (think about transparent distribution)

* Access to some persistent-storages like databases (imagine an
  SQL object mapper which looks like real object)

* Access to external data structures, like other languages as normal
  objects. (Of course some operations on them could raise exceptions, but it's
  purely done in application level, so it's not real problem)

Random notes:
-------------

Transparent proxy is implemented on top of `standard object space`_, in
`proxy_helpers.py`_, `proxyobject.py`_ and `transparent.py`_. To run it
you need to pass ``--with-transparent-proxy`` option to ``py.py`` or
``translate.py``. It registers implementations like a ``W_TransparentXxx``
which usually corresponds to an apropriate ``W_XxxObject``, including some
interpreter hacks for objects that are too close to the interpreter
to be implemented in a std objspace. The types of objects that can be proxied
like this are:
user created classes & functions, lists, dicts, exceptions, tracebacks and
frames.

.. _`standard object space`: objspace.html#the-standard-object-space
.. _`proxy_helpers.py`: ../../pypy/objspace/std/proxy_helpers.py
.. _`proxyobject.py`: ../../pypy/objspace/std/proxyobject.py
.. _`transparent.py`: ../../pypy/objspace/std/transparent.py

.. include:: _ref.txt
