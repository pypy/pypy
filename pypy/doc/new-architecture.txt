==================================================
PyPy - Goals and Architecture Overview 
==================================================

.. contents::
.. sectnum::

This document gives an overview of the goals and architecture of PyPy.
See `getting started`_ for a practical introduction and starting points. 

Mission statement 
====================

We aim to provide:

* a common translation and support framework for generating interpreters
  and implementations of dynamic languages, supporting a clean separation 
  between language specification and implementation aspects. 

* a compliant and fast Python Language interpreter 
  enabling new advanced features without the requirement
  to encode low level details into it. 

The choice of target platform as well as advanced optimizations 
techniques are to become aspects of the translation process, up
to the ultimate point of *generating Just-in-Time compilers* 
for dynamic language interpreters. 

.. XXX <arigo>
   the above wording looks nice, but somehow I end up missing all
   these notions that were more explicit in the previous missing statement:
   flexibility, variety of platforms large and small, custom Python
   versions, memory and threading models, robustness against language
   change, generating complete VMs, and the proof that it's really not
   only for Python because we have other interpreters already...

.. here's mwh's rewrite:

We aim to provide:

 * a common translation and support framework for producing
   implementations of dynamic languages, emphasising a clean
   separation between language specification and implementation
   aspects.

 * a flexible and fast implementation of the Python Language using
   the above framework to enable new advanced features without having
   to encode low level details into it.

By separating concerns in this way, we intend for our implementation
of Python - and other dynamic languages - to become robust against almost 
all implementation decisions, including target platform, memory and 
threading models, optimizations applied, up to to the point of being able to
automatically *generate* Just-in-Time compilers for dynamic languages.

Conversely, our implementation techniques, including the JIT compiler 
generator, should become robust against changes in the languages 
implementated.

High Level Goals
=============================

PyPy - The Translation Framework 
-----------------------------------------------

Traditionally, language interpreters are written in a target platform language
like C/Posix, Java or C#.  Each such implementation fundamentally provides 
a mapping from application source code to the target environment.  One of 
the goals of the "all-encompassing" environments, like the .NET framework
and to some extent the Java virtual machine, is to provide standardized
and higher level functionalities in order to support language implementors
for writing language implementations. 

PyPy is experimenting with a more ambitious approach.  We are using a
subset of a VHLL language, called RPython, to specify languages
with few references to and dependencies on lower level details,
leaving it to the translation framework to add these as translation
aspects and produce custom implementations for particular feature
and platform configurations.  

Particularly, we want to help avoiding having to write ``l * o * p``
interpreters for ``l`` dynamic languages and ``p`` platforms
with ``o`` crucial design decisions.  PyPy aims at having any
one of these parameters changeable independently from each
other:

* ``l``: modify or replace the language we analyse and regenerate
  a concrete interpreter for each target;

* ``o``: tweak and optimize the translation process to produce 
  platform specific code based on different models and trade-offs;

* ``p``: write new translator back-ends to target 
  different physical and virtual platforms.

By contrast, a standardized target environment - say .NET -
enforces ``p=1`` as far as it's concerned.  This helps making ``o`` a
bit smaller by providing a higher-level base to build upon.  Still,
we believe that enforcing the use of one common environment 
is not necessary.  PyPy's goal is to give weight to this claim - at least 
as far as language implementation is concerned - showing an approach
to the ``l * o * p`` problem that does not rely on standardization.

Particularly, we set ourselves the goal to *generate
Just-In-Time Compilers* in addition to traditional
interpreted implementations - an area of language
implementation that is commonly considered very challenging
because of the involved complexity. 


PyPy - the Python Interpreter 
--------------------------------------------

Our goal is to provide a full featured, customizable and fast Python
implementation, written in a subset of Python itself, working on and interacting 
with a large variety of platforms and allowing the quick introduction of
new advanced language features. 

The architecture and abstractions of PyPy's "Python language specification" 
aim to enable new implementation and optimization features that 
traditionally require pervasive changes in a language implementation 
source code. 

An important aspect of implementing Python in RPython is the high level of
abstraction and compactness of the language. This allows an implementation
that is, in many respects, easier to understand and play with than the one
written in C (referred to throughout the PyPy documentation and source as
"CPython").

Another goal is to specify the language implementation in the form
of a number of independent modules and abstractions, with clearly defined and 
automatically tested APIs.  This eases reuse and allows experimenting with 
variations and combinations of features. 

Our Python language implementation architecture, however, also serves as a 
key part for the translation framework:  we re-use its bytecode evaluator 
to analyse RPython programs, PyPy's implementation language for specifying 
language semantics and interpretation. 


PyPy Architecture 
===========================

As you would expect from a project implemented using ideas from the world
of `Extreme Programming`_, the architecture of PyPy has evolved over time
and continues to evolve.  Nevertheless, the high level architecture is 
stable. There are two rather independent basic subsystems: the `Python 
Interpreter`_ and `the Translation Framework`_.  We first talk about the 
Python Interpreter because of its re-use by the Translation framework.

.. _`standard interpreter`: 
.. _`python interpreter`: 

The Python Interpreter
-------------------------------------

PyPy's *Python Interpreter* implements the Python language
with the following key components: 

- a bytecode compiler responsible for producing Python code objects 

- a `bytecode evaluator`_ responsible for interpreting 
  Python code objects. 

- an `standard object space`_ responsible for creating, accessing and
  modifying Python application level objects.  

The *bytecode evaluator* is the part that interprets the compact
bytecode format produced from user Python sources by a preprocessing
phase, the *bytecode compiler*.  The bytecode compiler itself is
implemented as a chain of flexible passes (tokenizer, lexer, parser,
abstract syntax tree builder, bytecode generator).  The bytecode
evaluator does its work by delegating all actual manipulations of
user objects to the *object space*.  The latter can be thought of as the
library of built-in types.  It defines the implementation of the user
objects, like integers and lists, as well as the operations between
them, like addition or truth-value-testing.  

This division between bytecode evaluator and object space is very
important, as it gives a lot of flexibility. It is possible to use
different `object spaces`_ to get different behaviours of the Python
objects.  Using a special object space is also an important technique
for our translation process.

.. XXX there's something about the middle sentence of the above
   paragraph that i don't like -- maybe it's just that "different
   behaviours" reads strangely to me.

.. _`bytecode evaluator`: interpreter.html
.. _`standard object space`: objspace.html#the-standard-object-space
.. _`object spaces`: objspace.html
.. _`flow object space`: objspace.html#the-flow-object-space

.. _`the translation framework`:

The Translation Process
-----------------------

The job of translation tool chain is to translate RPython_ programs into an
efficient version of that program for one of various target platforms,
generally one that is considerably lower-level than Python.

A vital detail of PyPy's approach is that the level of abstraction is
reduced in several steps from the high level of RPython down to that
of the target platform, whatever that may be.

The translation tool chain never sees Python source code or syntax
trees, but rather starts with the *code objects* that define the
behaviour of the function objects one gives it as input.

The steps the translation process can be summarized as follows:

 * A code object is converted to a control flow graph, by the Flow
   Object Space.

 * The control flow graphs are processed by the Annotator, which
   annotates each variable of the control flow graph with the types it
   may take at run-time.

 * The information provided by the annotator is used by the RTyper to
   convert the high level operations of the control flow graphs into
   operations closer to abstraction level of the target platform.

 * Optionally, various transformations can then applied which, for
   example, perform optimizations such as inlining or add capabilities
   such as stackless-style concurrency.

 * Then, the graph is converted to source code for the target platform
   and compiled into an executable.

This process is described in much more detail in the `document about
the translation process`_.

.. _`document about the translation process`: translation.html

Further reading
===============

* `[VMC]`_ PyPy's approach to virtual machine construction
  (Dynamic Languages Symposium 2006).

* The `translation document`_ describes our translation process in detail.
  You might also be interested in reading the more
  theoretically-oriented paper `Compiling dynamic language
  implementations`_.

* All our `Technical reports`_. XXX reference specific reports
  and provide a summary here? 

* `Getting started`_ with PyPy for a practical introduction. 

.. _`Extreme Programming`: http://www.extremeprogramming.com/
.. _`statistics web page`: http://codespeak.net/~hpk/pypy-stat/
.. _`very compliant`: http://www2.openend.se/~pedronis/pypy-c-test/allworkingmodules/summary.html
.. _`Boehm-Demers-Weiser garbage collector`: http://www.hpl.hp.com/personal/Hans_Boehm/gc/
.. _`RPython`: coding-guide.html#rpython
.. _`abstract interpretation`: theory.html#abstract-interpretation
.. _`Compiling dynamic language implementations`: dynamic-language-translation.html
.. _`translation document`: translation.html
.. _LLVM: http://llvm.org/
.. _`PDF color version`: image/translation.pdf
.. _`getting started`: getting-started.html
.. _`[VMC]`: http://codespeak.net/svn/pypy/extradoc/talk/dls2006/pypy-vm-construction.pdf
.. _`Technical reports`: index-report.html

.. _Python: http://docs.python.org/ref
.. _Psyco: http://psyco.sourceforge.net
.. _Stackless: http://stackless.com 

.. include:: _ref.txt

