#!/usr/bin/python

BUFSIZE = 1024

import path
import sys
import random
from pypy.tool.build import config

from py.execnet import SshGateway, PopenGateway
from pypy.tool.build.client import init
from pypy.config.config import to_optparse, Config
from pypy.config import pypyoption

from pypy.translator.goal import targetpypystandalone
from pypy.translator.driver import TranslationDriver

if config.server in ['localhost', '127.0.0.1']:
    gw = PopenGateway()
else:
    gw = SshGateway(config.server)
channel = init(gw, config.system_config, path=config.path,
                port=config.port)

print channel.receive() # welcome message
try:
    try:
        while 1:
            data = channel.receive()
            if isinstance(data, str):
                continue
            if not isinstance(data, tuple): # needs more checks here
                raise ValueError(
                    'received wrong unexpected data of type %s' % (
                            type(data),)
                )
            sysinfo, compileinfo = data
            # XXX we should compile here, using data dict for info
            print 'compilation requested for info %r, now faking that' % (
                    data,)
            config = Config(pypyoption.pypy_optiondescription)
            config.override(compileinfo)

            # XXX compile here...
            driver = TranslationDriver.from_targetspec(
                        targetpypystandalone.__dict__, config=config,
                        default_goal='compile')
            driver.proceed()

            # write the zip to the server in chunks to server
            # XXX we're still faking this
            zipfp = (path.packagedir / 'test/test.zip').open()
            while True:
                chunk = zipfp.read(BUFSIZE)
                if not chunk:
                    break
                channel.send(chunk)
            channel.send(None) # tell the server we're done
            print 'done with compilation, waiting for next'
    except EOFError:
        sys.exit()
finally:
    channel.close()
    gw.exit()
